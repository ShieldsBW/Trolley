<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Trolley Problem Prototype</title>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3/dist/phaser.min.js"></script>
  <style>
    :root {
      --vh: 1vh; /* Will be set by JS to actual viewport height */
      /* Phase 3: Responsive design variables */
      --question-frame-width: min(750px, 95vw);
      --question-frame-height: min(225px, 30vh);
      --choice-frame-width: min(400px, 45vw);
      --choice-frame-height: min(160px, 22vh);
      --font-size-base: clamp(14px, 2vw, 18px);
      --font-size-large: clamp(18px, 3vw, 24px);
      --font-size-xlarge: clamp(24px, 4vw, 36px);
      --min-touch-target: 44px;
      --spacing-unit: clamp(8px, 2vw, 16px);
    }
    html, body {
      margin: 0;
      padding: 0;
      height: calc(var(--vh, 1vh) * 100);
      overflow: hidden;
      touch-action: manipulation; /* Disable double-tap zoom */
    }
    canvas { display: block; margin: 0 auto; }

    /* Prevent text selection on interactive elements (mobile UX) */
    button, img, [role="button"], .zone-marker, [onclick],
    .choice-frame, #game-hud, .item-btn, [id*="btn-"] {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Portrait orientation overlay - forces landscape */
    #portrait-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 99999;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #F5DEB3;
      font-family: Georgia, serif;
      text-align: center;
      padding: 20px;
      box-sizing: border-box;
    }
    #portrait-overlay .rotate-icon {
      font-size: 64px;
      margin-bottom: 20px;
      animation: rotate-hint 2s ease-in-out infinite;
    }
    @keyframes rotate-hint {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(90deg); }
    }
    #portrait-overlay h2 {
      color: #FFD700;
      font-size: 24px;
      margin: 0 0 10px 0;
    }
    #portrait-overlay p {
      font-size: 16px;
      margin: 0;
      opacity: 0.8;
    }

    /* Show overlay only on very small screens where portrait is impractical */
    @media screen and (orientation: portrait) and (max-width: 320px) and (max-height: 480px) {
      #portrait-overlay {
        display: flex !important;
      }
    }

    /* Ensure all clickable elements meet minimum touch target size */
    button, [role="button"], .zone-marker, [onclick] {
      min-width: var(--min-touch-target);
      min-height: var(--min-touch-target);
    }

    /* Debug outline styles - only visible when body has debug-active class */
    /* Frames - red */
    body.debug-active [id*="frame"],
    body.debug-active [id*="Frame"] { outline: 1px solid red !important; }
    /* Safe areas - lime */
    body.debug-active [id*="safe-area"],
    body.debug-active [id*="Safe"] { outline: 1px solid lime !important; }
    /* Buttons - cyan */
    body.debug-active [id*="btn-"],
    body.debug-active [id*="tab-"],
    body.debug-active button { outline: 1px solid cyan !important; }
    /* Text elements - yellow */
    body.debug-active [id*="text"],
    body.debug-active [id*="Text"],
    body.debug-active [id*="-desc"],
    body.debug-active [id*="-name"],
    body.debug-active p { outline: 1px solid yellow !important; }
    /* Containers - magenta */
    body.debug-active [id*="container"],
    body.debug-active [id*="Container"],
    body.debug-active [id*="-content"],
    body.debug-active [id*="items"] { outline: 1px solid magenta !important; }
    /* Logo - orange */
    body.debug-active [id*="logo"],
    body.debug-active [id*="Logo"] { outline: 1px solid orange !important; }
    /* Welcome/currency display - white */
    body.debug-active [id*="welcome"],
    body.debug-active [id*="currency"] { outline: 1px solid white !important; }
    /* Titles/headings - coral */
    body.debug-active [id*="title"],
    body.debug-active [id*="Title"],
    body.debug-active h1,
    body.debug-active h2 { outline: 1px solid coral !important; }
    /* Zone elements - gold */
    body.debug-active [id*="zone-detail"],
    body.debug-active [id*="zone-marker"],
    body.debug-active .zone-marker { outline: 1px solid gold !important; }
    /* Shop elements - violet */
    body.debug-active [id*="shop-"],
    body.debug-active [id*="profile-"] { outline: 1px solid violet !important; }
    /* Progress bars - springgreen */
    body.debug-active [id*="progress"] { outline: 1px solid springgreen !important; }
    /* Item bar elements - deepskyblue */
    body.debug-active [id*="item-"] { outline: 1px solid deepskyblue !important; }
    /* Leaderboard elements - lightsalmon */
    body.debug-active [id*="leaderboard-"] { outline: 1px solid lightsalmon !important; }
    /* Consequence elements - tomato */
    body.debug-active [id*="consequence-"] { outline: 1px solid tomato !important; }
    /* HUD elements - dodgerblue */
    body.debug-active [id*="hud-"],
    body.debug-active #game-hud { outline: 1px solid dodgerblue !important; }
    /* Game Over elements - limegreen */
    body.debug-active [id*="go-"],
    body.debug-active #go-total-points,
    body.debug-active #go-btn-container { outline: 1px solid limegreen !important; }
    /* Zone Progress Tracker - cyan */
    body.debug-active #zone-progress-tracker,
    body.debug-active #progress-svg,
    body.debug-active #progress-trolley { outline: 1px solid cyan !important; }
    /* Swipe card elements */
    body.debug-active #swipe-card-container { outline: 2px solid hotpink !important; }
    body.debug-active #swipe-card { outline: 2px solid orangered !important; }
    body.debug-active .swipe-choice-section { outline: 1px solid lime !important; }
    body.debug-active .swipe-direction-label { outline: 1px solid yellow !important; }
    body.debug-active .swipe-choice-text { outline: 1px solid cyan !important; }
    body.debug-active .swipe-choice-stats { outline: 1px solid magenta !important; }

    /* Zone Complete popup animation */
    @keyframes zoneCompleteScaleIn {
      from { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      to { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    }
    .zone-complete-animate {
      animation: zoneCompleteScaleIn 0.4s ease-out forwards;
    }

    /* Zone marker selection and hover styles */
    .zone-marker {
      transform: scale(1);
    }
    .zone-marker:hover {
      transform: scale(1.1);
      filter: drop-shadow(0 6px 12px rgba(0,0,0,0.8)) brightness(1.1) !important;
    }
    .zone-marker.selected {
      transform: scale(1.15);
      filter: drop-shadow(0 0 15px rgba(255,215,0,0.8)) drop-shadow(0 6px 12px rgba(0,0,0,0.8)) brightness(1.2) !important;
    }
    .zone-marker.locked {
      filter: grayscale(70%) drop-shadow(0 4px 8px rgba(0,0,0,0.7)) !important;
      cursor: not-allowed;
    }
    .zone-marker.locked:hover {
      transform: scale(1.02);
      filter: grayscale(70%) drop-shadow(0 4px 8px rgba(0,0,0,0.7)) !important;
    }

    /* Difficulty selector styles */
    .difficulty-btn {
      width: 36px;
      height: 36px;
      border: 2px solid #666;
      border-radius: 8px;
      background: rgba(0,0,0,0.5);
      color: #aaa;
      font-family: Arial, sans-serif;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.2s;
      margin: 0 4px;
    }
    .difficulty-btn:hover:not(.locked) {
      border-color: #FFD700;
      color: #FFD700;
    }
    .difficulty-btn.selected {
      border-color: #FFD700;
      background: rgba(255, 215, 0, 0.3);
      color: #FFD700;
    }
    .difficulty-btn.locked {
      opacity: 0.4;
      cursor: not-allowed;
    }

    #debug-btn {
      position: fixed;
      top: 140px;
      right: 20px;
      width: 30px;
      height: 30px;
      background: rgba(255,255,255,0.3);
      border: 1px solid rgba(255,255,255,0.5);
      border-radius: 4px;
      cursor: pointer;
      z-index: 9999;
      font-size: 16px;
      line-height: 28px;
      text-align: center;
      user-select: none;
    }
    #debug-btn:hover { background: rgba(255,255,255,0.5); }
    #debug-btn:active { background: rgba(255,255,255,0.7); }

    #debug-unlock-btn {
      position: fixed;
      top: 180px;
      right: 20px;
      width: 30px;
      height: 30px;
      background: rgba(255,200,100,0.3);
      border: 1px solid rgba(255,200,100,0.5);
      border-radius: 4px;
      cursor: pointer;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }
    #debug-unlock-btn:hover { background: rgba(255,200,100,0.5); }
    #debug-unlock-btn:active { background: rgba(255,200,100,0.7); }

    /* =====================================================
       Phase 3: Responsive Media Queries
       ===================================================== */

    /* Tablet breakpoint (768px) */
    @media screen and (max-width: 768px) {
      :root {
        --question-frame-width: min(700px, 92vw);
        --choice-frame-width: min(350px, 44vw);
        --font-size-base: clamp(13px, 2.5vw, 16px);
      }

      /* Reduce zone marker sizes for tablets */
      .zone-marker {
        width: min(80px, 18vw) !important;
        height: min(80px, 18vw) !important;
      }

      /* Adjust shop grid */
      #shop-items-grid > div {
        width: 150px !important;
        margin: 4px !important;
      }

      /* Smaller buttons */
      .difficulty-btn {
        width: 32px !important;
        height: 32px !important;
        font-size: 14px !important;
      }
    }

    /* Mobile breakpoint (480px) */
    @media screen and (max-width: 480px) {
      :root {
        --question-frame-width: 95vw;
        --question-frame-height: min(180px, 28vh);
        --choice-frame-width: 90vw;
        --choice-frame-height: min(120px, 18vh);
        --font-size-base: clamp(12px, 3.5vw, 15px);
        --font-size-large: clamp(14px, 4vw, 20px);
      }

      /* Stack choice buttons vertically on mobile */
      #choices-container > div {
        flex-direction: column !important;
        align-items: center !important;
        gap: 15px !important;
      }

      #choice-a-frame, #choice-b-frame {
        width: var(--choice-frame-width) !important;
        height: var(--choice-frame-height) !important;
      }

      /* Reduce zone marker sizes for mobile */
      .zone-marker {
        width: min(65px, 16vw) !important;
        height: min(65px, 16vw) !important;
      }

      /* Shop grid single column */
      #shop-items-grid > div {
        width: 95% !important;
        max-width: 280px !important;
        margin: 6px auto !important;
      }

      /* Zone detail panel - full width */
      #zone-detail-frame {
        width: 95vw !important;
        right: 2.5vw !important;
      }

      /* Item bar - vertical on left side */
      #item-bar {
        left: 8px !important;
        top: 50% !important;
        transform: translateY(-50%) !important;
        padding: 6px !important;
        gap: 5px !important;
        width: 60px !important;
      }
      #item-bar button {
        padding: 5px 3px !important;
        font-size: 9px !important;
      }

      /* HUD - smaller text */
      #game-hud {
        padding: 10px !important;
      }
      #hud-health, #hud-points {
        font-size: 16px !important;
      }
      #hud-level, #hud-stage, #hud-zone {
        font-size: 14px !important;
      }
    }

    /* Very small screens (320px) */
    @media screen and (max-width: 320px) {
      :root {
        --min-touch-target: 40px;
      }

      /* Smallest screens - compact zone markers */
      .zone-marker {
        width: min(50px, 15vw) !important;
        height: min(50px, 15vw) !important;
      }
    }

    /* Landscape orientation on mobile */
    @media screen and (max-height: 480px) and (orientation: landscape) {
      /* Login screen - compact for landscape mobile */
      #login-container > div {
        top: 50% !important;
        transform: translate(-50%, -50%) scale(0.85) !important;
      }
      #login-container img[alt="Trolley Problem"] {
        width: min(350px, 50vw) !important;
        margin-bottom: 0 !important;
      }
      #login-container p {
        font-size: 14px !important;
        margin-top: 2px !important;
        margin-bottom: 15px !important;
      }
      #login-container > div > div {
        padding: 15px 20px !important;
      }
      #login-container input {
        padding: 8px !important;
        font-size: 16px !important;
        margin-bottom: 10px !important;
      }
      #login-container button {
        padding: 8px !important;
        font-size: 14px !important;
        margin: 3px !important;
      }

      /* Main menu - compact for landscape mobile */
      #menu-logo {
        left: 5% !important;
        top: 5% !important;
        width: min(220px, 30vw) !important;
      }
      #menu-welcome-display {
        top: 45% !important;
        left: 5% !important;
        font-size: 12px !important;
        transform: none !important;
        text-align: left !important;
      }
      #menu-points-display {
        top: 55% !important;
        left: 5% !important;
        font-size: 12px !important;
        transform: none !important;
        text-align: left !important;
      }
      #btn-worldmap {
        top: 50% !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        height: 55px !important;
      }
      #btn-shop, #btn-leaderboard, #btn-profile {
        top: 78% !important;
        height: 35px !important;
      }
      #btn-shop {
        left: calc(50% - 100px) !important;
      }
      #btn-leaderboard {
        left: 50% !important;
      }
      #btn-profile {
        left: calc(50% + 100px) !important;
      }
      #btn-logout {
        bottom: 5px !important;
        left: 50% !important;
        height: 30px !important;
      }
      /* Hide quit button on mobile */
      #btn-quit {
        display: none !important;
      }

      /* World map - adjust for landscape */
      #worldmap-title {
        font-size: 18px !important;
        left: 10px !important;
        top: 8px !important;
      }
      #zone-markers {
        width: 48% !important;
        left: 0% !important;
        top: 15% !important;
        height: 75% !important;
      }
      #zone-markers svg {
        overflow: visible !important;
      }
      .zone-marker {
        width: min(55px, 14vw) !important;
        height: min(55px, 14vw) !important;
      }
      /* Zone detail frame - enlarged, reduced top/bottom margins */
      #zone-detail-frame {
        width: min(320px, 42vw) !important;
        right: 1% !important;
        top: 3% !important;
        bottom: 3% !important;
        height: auto !important;
        transform: none !important;
      }
      /* Safe zone - adjusted: top at 18%, bottom raised up */
      #zone-detail-safe-area {
        top: 16% !important;
        left: 16% !important;
        right: 16% !important;
        bottom: 28% !important;
        justify-content: flex-start !important;
        padding-top: 2% !important;
      }
      /* Zone name now inside safe area */
      #zone-detail-name {
        font-size: 12px !important;
        margin-bottom: 2px !important;
      }
      #zone-detail-safe-area h2 {
        font-size: 12px !important;
        margin-bottom: 2px !important;
      }
      #zone-detail-desc,
      #zone-detail-safe-area p {
        font-size: 8px !important;
        margin-bottom: 4px !important;
        line-height: 1.2 !important;
      }
      #zone-detail-safe-area > div {
        margin-bottom: 3px !important;
      }
      #zone-detail-safe-area span {
        font-size: 7px !important;
      }
      #zone-detail-safe-area > div > div {
        font-size: 9px !important;
        margin-top: 1px !important;
      }
      /* Progress bar */
      #zone-detail-safe-area > div > div[style*="background:rgba(255,255,255,0.2)"] {
        height: 8px !important;
      }
      /* Difficulty selector - buttons halved in size, text/icons same */
      #zone-difficulty-selector {
        margin-bottom: 3px !important;
      }
      #zone-difficulty-selector > span {
        margin-bottom: 2px !important;
      }
      .difficulty-btn {
        width: 22px !important;
        height: 22px !important;
        font-size: 11px !important;
        margin: 0 3px !important;
        padding: 0 !important;
        min-width: 22px !important;
        min-height: 22px !important;
      }
      #zone-difficulty-multiplier {
        font-size: 8px !important;
        margin-top: 2px !important;
      }
      /* Locked message */
      #zone-detail-locked {
        font-size: 9px !important;
        margin-bottom: 3px !important;
      }
      /* Start button inside safe area */
      #btn-zone-start {
        width: 80px !important;
        margin-top: 2px !important;
      }

      /* Game HUD - more compact for mobile */
      #game-hud {
        top: 3px !important;
        left: 5px !important;
        right: 5px !important;
        padding: 4px 8px !important;
        font-size: 11px !important;
      }
      #hud-health, #hud-points {
        font-size: 12px !important;
        margin-bottom: 2px !important;
      }
      #hud-level, #hud-stage, #hud-zone {
        font-size: 10px !important;
        margin-bottom: 3px !important;
      }
      /* HUD inventory button - positioned lower to avoid text overlap */
      #hud-inventory-btn {
        top: 85px !important;
        right: 8px !important;
        width: 36px !important;
        height: 36px !important;
      }

      /* Question frame - scaled down 10% horizontally and vertically */
      #question-frame {
        top: 45px !important;
        width: min(81vw, 450px) !important;
        height: min(100px, 22vh) !important;
      }
      #question-safe-area {
        top: 16% !important;
        left: 7% !important;
        right: 7% !important;
        bottom: 16% !important;
      }
      #question-text {
        font-size: clamp(11px, 2.5vw, 16px) !important;
        line-height: 1.3 !important;
      }

      /* Choice boxes - raised up, scaled to 75% width */
      #choices-container {
        top: 140px !important;
        bottom: auto !important;
      }
      #choice-a-frame, #choice-b-frame,
      .choice-frame {
        width: min(31vw, 150px) !important;
        height: min(75px, 16vh) !important;
      }
      #choice-a-safe-area, #choice-b-safe-area {
        top: 16% !important;
        left: 8% !important;
        right: 8% !important;
        bottom: 16% !important;
      }
      #choice-a-text, #choice-b-text {
        font-size: clamp(10px, 2vw, 13px) !important;
        line-height: 1.2 !important;
      }

      /* Zone progress tracker - spans from below choices to near screen bottom */
      #zone-progress-tracker {
        top: calc(140px + min(75px, 16vh) + 5px) !important;  /* 5px below choice boxes */
        bottom: 10px !important;  /* 10px from screen bottom */
        height: auto !important;  /* Height determined by top/bottom */
        width: min(85vw, 500px) !important;
      }
      #zone-progress-tracker > div:first-child {
        /* Dark background with padding */
        left: -10px !important;
        top: -5px !important;
        right: -10px !important;
        bottom: -5px !important;
      }
      #progress-trolley {
        width: 30px !important;
        height: 30px !important;
      }

      /* Level complete text and next level button - positioned above tracker */
      #level-complete-text {
        top: 10% !important;  /* Near top but not clipping */
        font-size: clamp(24px, 5vh, 36px) !important;
        max-width: 85vw !important;
        text-shadow: 4px 4px 8px rgba(0,0,0,0.9), 2px 2px 4px rgba(0,0,0,0.8), 0 0 20px rgba(0,0,0,0.7) !important;
        z-index: 70 !important;  /* Above tracker */
        background: rgba(0,0,0,0.6) !important;
        padding: 10px 20px !important;
        border-radius: 10px !important;
      }
      #btn-next {
        top: calc(45% - 45px) !important;  /* Raised 45px, between text and tracker */
        height: 70px !important;
        width: auto !important;
        z-index: 70 !important;  /* Above tracker (which is z-index 45) */
      }

      /* Consequence frame - scaled up 20% */
      #consequence-frame {
        height: calc(var(--vh, 1vh) * 72) !important;
        width: calc(var(--vh, 1vh) * 72 * 1.5) !important;
      }
      /* Consequence safe area - scaled down 5% vertically */
      #consequence-safe-area {
        top: 20% !important;
        bottom: 13% !important;
      }
      #consequence-text {
        font-size: clamp(14px, 2.5vh, 20px) !important;
      }
      #consequence-stats {
        font-size: clamp(12px, 2vh, 16px) !important;
      }

      /* Zone complete popup - similar scaling */
      #zone-complete-frame {
        height: calc(var(--vh, 1vh) * 72) !important;
        width: calc(var(--vh, 1vh) * 72 * 1.5) !important;
      }
      #zone-complete-safe-area {
        top: 20% !important;
        bottom: 13% !important;
      }
      #zone-complete-title {
        font-size: clamp(20px, 4vh, 32px) !important;
      }
      #zone-complete-subtitle {
        font-size: clamp(12px, 2.5vh, 18px) !important;
      }

      /* Menu button position - larger touch target */
      #btn-menu {
        right: 8px !important;
        bottom: 8px !important;
        transform: scale(0.45) !important;
        transform-origin: bottom right !important;
      }

      /* Game Over screen - redesigned for landscape */
      #go-title {
        left: 15% !important;
        top: 20% !important;
        transform: none !important;
        height: auto !important;
        width: min(30vw, 250px) !important;
      }
      #go-total-points {
        left: 15% !important;
        top: 55% !important;
        transform: none !important;
        text-align: left !important;
        font-size: 18px !important;
      }
      #go-btn-container {
        left: 70% !important;
        top: 50% !important;
        transform: translate(-50%, -50%) !important;
        flex-direction: column !important;
        gap: 8px !important;
        width: auto !important;
      }
      #go-btn-container img {
        width: min(180px, 25vw) !important;
        height: auto !important;
      }

      /* Shop page - landscape layout, positioned right */
      #shop-frame {
        width: calc(var(--vh, 1vh) * 90 * 1.3) !important;
        height: calc(var(--vh, 1vh) * 90) !important;
        left: auto !important;
        right: 5% !important;
        transform: translateY(-50%) !important;
      }
      #shop-safe-area {
        top: 6% !important;
        left: 6% !important;
        right: 6% !important;
        bottom: 6% !important;
      }
      #shop-title {
        font-size: clamp(14px, 3vh, 20px) !important;
        margin-bottom: 0.2vh !important;
      }
      #shop-points {
        font-size: clamp(9px, 1.5vh, 11px) !important;
        margin-bottom: 0.2vh !important;
      }
      /* Shop tabs - halved vertical size */
      #shop-tabs {
        margin-bottom: 0.3vh !important;
      }
      #shop-tabs button {
        padding: 1px 8px !important;
        font-size: clamp(8px, 1.3vh, 10px) !important;
        line-height: 1.2 !important;
      }
      #shop-items {
        padding: 3px !important;
        flex: 1 !important;
        display: flex !important;
        flex-direction: column !important;
      }
      /* Shop items grid - 2 rows of 3 */
      #shop-items-grid {
        display: grid !important;
        grid-template-columns: repeat(3, 1fr) !important;
        grid-template-rows: repeat(2, 1fr) !important;
        gap: 6px !important;
        flex: 1 !important;
        align-content: start !important;
        overflow: hidden !important;
      }
      #shop-items-grid > div {
        width: auto !important;
        min-width: 0 !important;
        max-width: none !important;
        margin: 0 !important;
        padding: 3px !important;
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        justify-content: center !important;
      }
      #shop-items-grid > div img {
        width: 28px !important;
        height: 28px !important;
        margin-bottom: 2px !important;
      }
      #shop-items-grid > div span {
        font-size: 8px !important;
        line-height: 1.1 !important;
      }
      #shop-items-grid > div button {
        padding: 1px 4px !important;
        font-size: 8px !important;
        margin-top: 2px !important;
      }
      /* Shop pagination - halved vertical size */
      #shop-pagination {
        padding-top: 2px !important;
        margin-top: 2px !important;
        flex-shrink: 0 !important;
      }
      #shop-pagination button {
        padding: 1px 4px !important;
        font-size: 9px !important;
        line-height: 1.2 !important;
      }
      #shop-page-info {
        font-size: 8px !important;
      }
      #shop-btn-container {
        margin-top: 0.5vh !important;
      }
      #shop-btn-container img {
        height: clamp(25px, 5vh, 35px) !important;
      }

      /* Profile page - landscape layout */
      #profile-frame {
        width: calc(var(--vh, 1vh) * 90 * 1.3) !important;
        height: calc(var(--vh, 1vh) * 90) !important;
      }
      #profile-safe-area {
        top: 5% !important;
        left: 6% !important;
        right: 6% !important;
        bottom: 5% !important;
      }
      #profile-title {
        font-size: clamp(14px, 3vh, 20px) !important;
        margin-bottom: 0.2vh !important;
      }
      /* Profile tabs - halved vertical size like shop */
      #profile-tabs {
        margin-bottom: 0.3vh !important;
      }
      #profile-tabs button {
        padding: 1px 6px !important;
        font-size: clamp(7px, 1.2vh, 9px) !important;
        line-height: 1.2 !important;
      }
      #profile-tab-content {
        padding: 4px !important;
        font-size: 9px !important;
        overflow: hidden !important;
      }
      /* Stats tab - hide the controller/user icon on mobile */
      #profile-tab-content > div:first-child > div:first-child {
        display: none !important;
      }
      /* Stats tab - compact layout without icon */
      #profile-tab-content h2 {
        font-size: clamp(11px, 2vh, 14px) !important;
        margin: 2px 0 !important;
      }
      #profile-tab-content p {
        font-size: clamp(7px, 1vh, 9px) !important;
        margin-bottom: 3px !important;
      }
      #profile-tab-content > div:first-child {
        margin-bottom: 4px !important;
      }
      /* Stats grid - reduced spacing */
      #profile-tab-content > div > div[style*="grid"] {
        gap: 2px !important;
      }
      #profile-tab-content > div > div[style*="grid"] > div {
        padding: 3px !important;
      }
      #profile-tab-content > div > div[style*="grid"] > div > div:first-child {
        font-size: clamp(10px, 1.8vh, 14px) !important;
      }
      #profile-tab-content > div > div[style*="grid"] > div > div:last-child {
        font-size: clamp(6px, 0.9vh, 8px) !important;
      }
      /* Inventory tab - extra 5% horizontal inset */
      #profile-tab-content > div[style*="Trolley Skins"],
      #profile-tab-content > div:has(h3) {
        padding: 0 5% !important;
      }
      #profile-tab-content h3 {
        font-size: 10px !important;
        margin: 3px 0 2px 0 !important;
      }
      /* Inventory skin items */
      #profile-tab-content > div > div[style*="flex-wrap"] > div {
        width: 45px !important;
        padding: 3px !important;
      }
      #profile-tab-content > div > div[style*="flex-wrap"] > div > div:first-child {
        width: 35px !important;
        height: 22px !important;
      }
      /* Achievements - compact */
      #profile-tab-content > div[style*="flex-wrap"][style*="justify-content:center"] > div {
        width: 40px !important;
        padding: 3px !important;
      }
      #profile-tab-content > div[style*="flex-wrap"][style*="justify-content:center"] > div > div:first-child {
        font-size: clamp(12px, 2vh, 16px) !important;
      }
      #profile-tab-content > div[style*="flex-wrap"][style*="justify-content:center"] > div > div:last-child {
        font-size: clamp(5px, 0.8vh, 7px) !important;
      }
      #profile-btn-container {
        margin-top: 0.3vh !important;
      }
      #profile-btn-container img {
        height: clamp(25px, 5vh, 35px) !important;
      }

      /* Leaderboard page - landscape layout */
      #leaderboard-frame {
        width: calc(var(--vh, 1vh) * 90 * 1.3) !important;
        height: calc(var(--vh, 1vh) * 90) !important;
      }
      #leaderboard-safe-area {
        top: 6% !important;
        left: 15% !important;
        right: 15% !important;
        bottom: 6% !important;
      }
      #leaderboard-title {
        font-size: clamp(14px, 3vh, 20px) !important;
        margin-bottom: 0.5vh !important;
      }
      #leaderboard-entries {
        gap: 0.3vh !important;
      }
      #leaderboard-entries > div {
        font-size: clamp(9px, 1.5vh, 12px) !important;
        padding: 2px 5px !important;
      }
      #leaderboard-btn-container {
        display: flex !important;
        justify-content: center !important;
        width: 100% !important;
        margin-top: 1vh !important;
      }
      #leaderboard-btn-container img {
        height: clamp(35px, 7vh, 50px) !important;
      }

      /* Item bar - vertical on left side for landscape */
      #item-bar {
        left: 5px !important;
        top: 50% !important;
        bottom: auto !important;
        transform: translateY(-50%) !important;
        padding: 5px !important;
        font-size: 8px !important;
        gap: 3px !important;
        width: 50px !important;
      }
      #item-bar button {
        padding: 4px 2px !important;
        font-size: 8px !important;
      }
      #items-used {
        font-size: 7px !important;
      }

      /* Game inventory overlay */
      #game-inventory-panel {
        max-width: 280px !important;
        padding: 12px !important;
        max-height: 60vh !important;
      }
      #game-inventory-panel h2 {
        font-size: 18px !important;
        margin-bottom: 10px !important;
      }
      #game-inventory-items > div {
        padding: 8px !important;
      }
      #game-inventory-limit {
        font-size: 10px !important;
      }
      #game-inventory-close {
        padding: 8px 16px !important;
        font-size: 12px !important;
      }
      #hud-inventory-btn {
        width: 32px !important;
        height: 32px !important;
        top: 70px !important;
        right: 10px !important;
      }
      #hud-inventory-btn span {
        font-size: 16px !important;
      }
    }

    /* ============================================
       PORTRAIT ORIENTATION SUPPORT (Mobile)
       ============================================ */
    @media screen and (orientation: portrait) and (max-width: 1200px) {
      /* CSS Variables for portrait mode */
      :root {
        --swipe-card-width: min(85vw, 350px);
        --swipe-card-height: auto;
        --portrait-question-top: 8%;
        --portrait-card-center: 45%;
        --portrait-tracker-bottom: 5%;
      }

      /* Hide traditional side-by-side choices in portrait */
      #choices-container {
        display: none !important;
      }

      /* Question frame repositioned to top - below HUD, moved down 50px, 20% taller */
      #question-frame {
        top: calc(14% + 15px) !important;
        width: min(92vw, 500px) !important;
        height: auto !important;
        min-height: 150px !important;
        transform: translateX(-50%) !important;
      }

      #question-safe-area {
        left: 20% !important;
        right: 20% !important;
      }

      #question-text {
        font-size: 14px !important;
        line-height: 1.3 !important;
      }

      /* Zone progress tracker at bottom */
      #zone-progress-tracker {
        bottom: var(--portrait-tracker-bottom) !important;
        top: auto !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
      }

      /* Trolley icon in progress tracker - 10% smaller */
      #zone-progress-tracker .trolley-icon,
      #zone-progress-tracker [style*="trolley"] {
        transform: scale(0.9) !important;
      }

      /* Game HUD for portrait - reorganized layout */
      /* Note: display controlled by JS */
      #game-hud {
        top: 3px !important;
        left: 50% !important;
        right: auto !important;
        transform: translateX(-50%) !important;
        width: auto !important;
        max-width: 95vw !important;
        padding: 4px 10px !important;
        font-size: 11px !important;
        flex-wrap: wrap !important;
        justify-content: center !important;
        gap: 2px 12px !important;
      }

      /* Make container divs transparent to flexbox so children can be reordered */
      #hud-left, #hud-right {
        display: contents !important;
      }

      /* HUD items - keep label and value on same line, 2 per row */
      #hud-stage, #hud-level, #hud-health, #hud-points {
        white-space: nowrap !important;
        margin: 0 !important;
        position: static !important;
        flex: 0 0 45% !important;
        text-align: center !important;
      }

      /* Order: Stage, Level on top row; Health, Points on bottom */
      #hud-stage { order: 1 !important; }
      #hud-level { order: 2 !important; }
      #hud-health { order: 3 !important; }
      #hud-points { order: 4 !important; }
      #hud-zone { display: none !important; }

      /* Menu button positioning handled per-scene via JavaScript */

      /* Inventory button - below menu button (adjusted for smaller menu button) */
      #hud-inventory-btn {
        position: fixed !important;
        left: 8px !important;
        top: 45px !important;
        right: auto !important;
        width: 28px !important;
        height: 28px !important;
      }

      #hud-inventory-btn span {
        font-size: 14px !important;
      }

      /* Item bar repositioned for portrait */
      #item-bar {
        left: 5px !important;
        top: 90px !important;
        bottom: auto !important;
        transform: none !important;
        width: 50px !important;
        padding: 4px !important;
        font-size: 8px !important;
      }

      /* Level Complete - next button above visualization */
      #btn-next {
        top: 40% !important;
        z-index: 65 !important;
        width: min(50vw, 200px) !important;
        height: auto !important;
      }

      /* Level complete text - position above button */
      #level-complete-text {
        top: 18% !important;
        min-width: 85vw !important;
        max-width: 95vw !important;
        font-size: clamp(20px, 4vh, 32px) !important;
        padding: 10px 20px !important;
      }

      /* Swipe card container styles - properly centered */
      #swipe-card-container {
        position: fixed !important;
        left: 50% !important;
        top: 52% !important;
        transform: translate(-50%, calc(-50% + 30px)) !important;
        width: min(94vw, 380px) !important;
        z-index: 60 !important;
        touch-action: pan-y !important;
      }

      /* The swipeable card - side by side layout */
      #swipe-card {
        width: 100% !important;
        background: rgba(20, 20, 30, 0.95) !important;
        border: 3px solid #FFD700 !important;
        border-radius: 12px !important;
        padding: 12px !important;
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5) !important;
        transition: transform 0.1s ease-out, border-color 0.15s ease !important;
        cursor: grab !important;
        box-sizing: border-box !important;
      }

      #swipe-card:active {
        cursor: grabbing !important;
      }

      /* Side-by-side choices container */
      .swipe-choices-row {
        display: flex !important;
        gap: 8px !important;
      }

      /* Swipe card choice sections - side by side */
      .swipe-choice-section {
        flex: 1 !important;
        padding: 10px 8px !important;
        border-radius: 8px !important;
        min-height: 200px !important;
        display: flex !important;
        flex-direction: column !important;
        align-items: center !important;
        justify-content: center !important;
        text-align: center !important;
      }

      .swipe-choice-section.left {
        border-left: 3px solid #e94560 !important;
        border-top: none !important;
        background: rgba(233, 69, 96, 0.25) !important;
        box-shadow: inset 0 0 15px rgba(233, 69, 96, 0.4) !important;
      }

      .swipe-choice-section.right {
        border-right: 3px solid #4ecdc4 !important;
        border-left: none !important;
        background: rgba(78, 205, 196, 0.25) !important;
        box-shadow: inset 0 0 15px rgba(78, 205, 196, 0.4) !important;
      }

      .swipe-direction-label {
        font-size: 11px !important;
        font-weight: bold !important;
        text-transform: uppercase !important;
        letter-spacing: 0.5px !important;
        margin-bottom: 6px !important;
        display: flex !important;
        align-items: center !important;
        gap: 4px !important;
      }

      .swipe-direction-label .arrow {
        font-size: 16px !important;
      }

      .swipe-choice-section.left .swipe-direction-label {
        color: #e94560 !important;
      }

      .swipe-choice-section.right .swipe-direction-label {
        color: #4ecdc4 !important;
        justify-content: flex-end !important;
      }

      .swipe-choice-text {
        color: #F5DEB3 !important;
        font-family: Georgia, serif !important;
        font-size: 12px !important;
        line-height: 1.3 !important;
        margin-bottom: 6px !important;
        flex: 1 !important;
      }

      .swipe-choice-stats {
        color: #FFD700 !important;
        font-size: 10px !important;
        font-family: Arial, sans-serif !important;
      }

      /* Swipe indicators - hidden in new layout */
      .swipe-indicator {
        display: none !important;
      }

      /* Hide bottom hints - no longer needed */
      .swipe-hints {
        display: none !important;
      }

      /* Hide divider - no longer needed */
      .swipe-divider {
        display: none !important;
      }

      /* ========== MAIN MENU PORTRAIT ========== */
      #menu-logo {
        left: 50% !important;
        top: calc(5% - 20px) !important;
        transform: translateX(-50%) !important;
        width: min(91vw, 390px) !important;
      }

      #menu-welcome-display {
        top: calc(32% + 20px) !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        text-align: center !important;
        font-size: 13px !important;
        width: auto !important;
        background: rgba(0, 0, 0, 0.4) !important;
        padding: 6px 15px !important;
        border-radius: 6px !important;
      }

      #menu-points-display {
        top: calc(36% + 20px) !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        text-align: center !important;
        font-size: 13px !important;
        background: rgba(0, 0, 0, 0.4) !important;
        padding: 6px 15px !important;
        border-radius: 6px !important;
      }

      #btn-worldmap {
        top: calc(44% + 30px) !important;
        left: 50% !important;
        height: 80px !important;
        filter: drop-shadow(0 0 8px rgba(255, 215, 0, 0.6)) drop-shadow(0 0 15px rgba(255, 215, 0, 0.4)) !important;
        transition: transform 0.15s ease-out, filter 0.15s ease-out !important;
      }

      #btn-worldmap:active,
      #btn-worldmap.btn-pressed {
        transform: translateX(-50%) scale(1.1) !important;
        filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.9)) drop-shadow(0 0 25px rgba(255, 215, 0, 0.7)) brightness(1.2) !important;
      }

      /* Shop and Profile container - centered with flexbox */
      #menu-shop-profile-container {
        top: calc(56% + 65px) !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        display: flex !important;
        flex-direction: row !important;
        gap: 10px !important;
      }

      #menu-shop-profile-container #btn-shop,
      #menu-shop-profile-container #btn-profile {
        position: static !important;
        transform: none !important;
        height: 52px !important;
      }

      #btn-leaderboard {
        top: calc(66% + 65px) !important;
        left: 50% !important;
        height: 40px !important;
      }

      #btn-logout {
        bottom: 8% !important;
        left: 50% !important;
        height: 49px !important;
      }

      #btn-quit {
        display: none !important;
      }

      /* ========== WORLD MAP PORTRAIT ========== */
      #worldmap-title {
        top: 10px !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        font-size: 16px !important;
      }

      /* Debug button - far top right */
      #debug-btn {
        top: 8px !important;
        right: 8px !important;
        left: auto !important;
        bottom: auto !important;
        font-size: 18px !important;
      }

      /* Debug unlock button - world map only, next to debug btn */
      #debug-unlock-btn {
        top: 8px !important;
        right: 45px !important;
        left: auto !important;
        bottom: auto !important;
        font-size: 18px !important;
      }

      /* Zone markers container - centered on screen */
      #zone-markers {
        top: 6% !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        width: 90vw !important;
        height: 32% !important;
      }

      .zone-marker {
        width: min(55px, 16vw) !important;
        height: min(55px, 16vw) !important;
      }

      /* Shift zone icons left within container for better visual centering */
      .zone-marker[data-zone="1"] { left: 8% !important; }
      .zone-marker[data-zone="2"] { left: 33% !important; }
      .zone-marker[data-zone="3"] { left: 58% !important; }
      .zone-marker[data-zone="4"] { left: 78% !important; }

      /* Shift SVG connecting lines to match icon positions */
      #zone-markers svg line {
        transform: translateX(-7%) !important;
      }

      /* Hide menu button by default in portrait - scenes will show via JS if needed */
      #btn-menu {
        display: none !important;
      }

      /* World map return-to-menu button: top-left, half size */
      #btn-worldmap-back {
        left: 8px !important;
        top: 8px !important;
        bottom: auto !important;
        transform: scale(0.5) !important;
        transform-origin: top left !important;
      }

      /* Zone detail panel at bottom half */
      #zone-detail-frame {
        position: fixed !important;
        left: 50% !important;
        right: auto !important;
        top: auto !important;
        bottom: 2% !important;
        transform: translateX(-50%) !important;
        width: 92vw !important;
        height: 52vh !important;
        max-height: 52vh !important;
      }

      /* Safe area - scaled down content to fit, vertically centered, shifted down 10px */
      #zone-detail-safe-area {
        top: 8% !important;
        left: 20% !important;
        right: 20% !important;
        bottom: 15% !important;
        overflow: hidden !important;
        justify-content: center !important;
        padding-top: 10px !important;
      }

      #zone-detail-name {
        font-size: 11px !important;
        margin-bottom: 2px !important;
      }

      #zone-detail-desc {
        font-size: 8px !important;
        line-height: 1.2 !important;
        margin-bottom: 3px !important;
      }

      #zone-detail-safe-area p {
        font-size: 7px !important;
        line-height: 1.1 !important;
        margin-bottom: 2px !important;
      }

      #zone-detail-safe-area > div {
        margin-bottom: 2px !important;
      }

      #zone-detail-safe-area span {
        font-size: 6px !important;
      }

      .difficulty-btn {
        width: 23px !important;
        height: 23px !important;
        font-size: 11px !important;
        min-width: 23px !important;
        min-height: 23px !important;
        display: flex !important;
        align-items: center !important;
        justify-content: center !important;
        padding: 0 !important;
      }

      #zone-difficulty-selector {
        margin-bottom: 2px !important;
        margin-top: 10px !important;
      }

      #zone-difficulty-selector > span {
        font-size: 6px !important;
        margin-bottom: 1px !important;
      }

      /* Push buttons and multiplier down 10px from label */
      #zone-difficulty-selector > div:first-of-type {
        margin-top: 10px !important;
      }

      #zone-difficulty-multiplier {
        font-size: 6px !important;
      }

      #btn-zone-start {
        width: 70px !important;
        margin-top: 13px !important;
      }

      /* ========== SHOP/PROFILE PORTRAIT ========== */
      #shop-frame, #profile-frame {
        width: 95vw !important;
        height: 92vh !important;
        max-width: 95vw !important;
      }

      #shop-safe-area, #profile-safe-area {
        top: 6% !important;
        left: 6% !important;
        right: 6% !important;
        bottom: 6% !important;
        overflow: hidden !important;
      }

      /* Shop title smaller */
      #shop-safe-area h2, #profile-safe-area h2 {
        font-size: 16px !important;
        margin-bottom: 6px !important;
      }

      /* Shop points display */
      #shop-points {
        font-size: 12px !important;
        margin-bottom: 6px !important;
      }

      /* Shop tabs */
      #shop-tabs {
        margin-bottom: 6px !important;
      }

      #shop-tabs button {
        padding: 5px 10px !important;
        font-size: 10px !important;
      }

      /* Shop grid - 2 columns, no scroll - pagination handles overflow */
      #shop-items-grid {
        display: grid !important;
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 5px !important;
        overflow: hidden !important;
      }

      .shop-item {
        padding: 5px !important;
        min-height: auto !important;
      }

      .shop-item-name {
        font-size: 9px !important;
        margin-bottom: 2px !important;
      }

      .shop-item-desc {
        font-size: 7px !important;
        line-height: 1.2 !important;
        margin-bottom: 3px !important;
      }

      .shop-item-price {
        font-size: 8px !important;
        margin-bottom: 3px !important;
      }

      .shop-item button {
        padding: 3px 6px !important;
        font-size: 8px !important;
        min-height: 22px !important;
      }

      /* Shop pagination */
      #shop-pagination {
        margin-top: 6px !important;
      }

      #shop-pagination button {
        padding: 4px 8px !important;
        font-size: 10px !important;
      }

      #shop-page-info {
        font-size: 10px !important;
      }

      /* Profile grid - 2 columns */
      #profile-items-grid {
        grid-template-columns: repeat(2, 1fr) !important;
        gap: 5px !important;
        overflow: hidden !important;
      }

      /* ========== LEADERBOARD PORTRAIT ========== */
      /* Container display controlled by JS - only style when visible */
      #leaderboard-frame {
        position: relative !important;
        left: auto !important;
        top: auto !important;
        transform: none !important;
        width: 90vw !important;
        height: 85vh !important;
        max-height: 85vh !important;
        margin: auto !important;
      }

      #leaderboard-safe-area {
        top: 12% !important;
        left: 12% !important;
        right: 12% !important;
        bottom: 12% !important;
      }

      #leaderboard-title {
        font-size: 20px !important;
        margin-bottom: 10px !important;
      }

      #leaderboard-entries {
        gap: 6px !important;
        overflow-y: auto !important;
      }

      #leaderboard-entries > div {
        font-size: 11px !important;
        padding: 6px 10px !important;
      }

      #leaderboard-btn-container {
        margin-top: 10px !important;
      }

      #leaderboard-btn-container img {
        height: 40px !important;
      }

      /* ========== GAME OVER PORTRAIT ========== */
      #go-title {
        top: 5% !important;
        width: min(70vw, 280px) !important;
        height: auto !important;
      }

      #go-total-points {
        top: 28% !important;
        font-size: 14px !important;
      }

      #btn-submit {
        top: 38% !important;
        width: min(140px, 38vw) !important;
      }

      /* Menu button - no portrait-specific positioning here
         Each scene controls its own positioning via JavaScript */

      #btn-try {
        top: 55% !important;
        width: min(180px, 50vw) !important;
      }

      #btn-worldmap-go {
        top: 68% !important;
        width: min(180px, 50vw) !important;
      }

      /* ========== ZONE COMPLETE POPUP PORTRAIT ========== */
      #zone-complete-frame {
        width: 90vw !important;
        max-width: 90vw !important;
        height: auto !important;
        aspect-ratio: 1.5 / 1 !important;
        max-height: 55vh !important;
      }

      #zone-complete-title {
        font-size: clamp(18px, 4vw, 28px) !important;
      }

      #zone-complete-subtitle {
        font-size: clamp(12px, 3vw, 18px) !important;
      }

      /* ========== CONSEQUENCE POPUP PORTRAIT ========== */
      #consequence-frame {
        width: 90vw !important;
        max-width: 90vw !important;
        height: auto !important;
        aspect-ratio: 1.5 / 1 !important;
        max-height: 50vh !important;
        left: 50% !important;
        top: 50% !important;
        transform: translate(-50%, -50%) !important;
      }

      #consequence-safe-area {
        padding: 48px 8px 8px 8px !important;
      }

      #consequence-text {
        font-size: 12px !important;
        line-height: 1.2 !important;
        margin-bottom: 8px !important;
      }

      #consequence-stats {
        font-size: 10px !important;
        margin-bottom: 8px !important;
      }
    }

    /* Swipe card animations */
    @keyframes swipeExitLeft {
      to {
        transform: translateX(-150vw) rotate(-30deg);
        opacity: 0;
      }
    }

    @keyframes swipeExitRight {
      to {
        transform: translateX(150vw) rotate(30deg);
        opacity: 0;
      }
    }

    @keyframes swipeSnapBack {
      to {
        transform: translateX(0) rotate(0deg);
      }
    }

    .swipe-exit-left {
      animation: swipeExitLeft 0.3s ease-out forwards !important;
    }

    .swipe-exit-right {
      animation: swipeExitRight 0.3s ease-out forwards !important;
    }

    .swipe-snap-back {
      animation: swipeSnapBack 0.2s ease-out forwards !important;
    }
  </style>
</head>
<body>
<!-- Portrait orientation overlay - shown when device is in portrait mode -->
<div id="portrait-overlay">
  <div class="rotate-icon"></div>
  <h2>Please Rotate Your Device</h2>
  <p>This game is best played in landscape mode</p>
</div>

<!-- Debug button - hold to show outlines -->
<div id="debug-btn" title="Hold to show debug outlines"></div>
<!-- Debug button - unlock all zones/difficulties (only visible on world map) -->
<div id="debug-unlock-btn" title="Unlock all zones and difficulties" style="display:none;"></div>

<img id="menu-bg" src="assets/backgrounds/menu_bg.png" alt="" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);object-fit:cover;z-index:-1;display:none;"/>
<img id="level-bg" src="assets/backgrounds/level_01_background.png" alt="" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);object-fit:cover;z-index:-1;display:none;"/>
<!-- Leaderboard Scene Elements -->
<div id="leaderboard-container" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);display:none;z-index:100;">
  <!-- Leaderboard frame - centered -->
  <div id="leaderboard-frame" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:calc(var(--vh, 1vh) * 90 * 0.64);height:calc(var(--vh, 1vh) * 90);">
    <!-- Frame image layer (aspect ratio 944:1472 = 0.64:1) -->
    <img src="assets/frames/frame_leaderboard.png" style="position:absolute;inset:0;width:100%;height:100%;object-fit:fill;pointer-events:none;"/>
    <!-- Safe area for content (insets: top 15%, right 15%, bottom 15%, left 15%) -->
    <div id="leaderboard-safe-area" style="position:absolute;top:15%;left:15%;right:15%;bottom:15%;display:flex;flex-direction:column;align-items:center;overflow:hidden;">
      <h1 id="leaderboard-title" style="color:#fff;font-family:Arial,sans-serif;font-size:clamp(24px, 5vh, 48px);margin:0 0 2vh 0;">Leaderboard</h1>
      <div id="leaderboard-entries" style="width:100%;flex:1;display:flex;flex-direction:column;justify-content:flex-start;gap:1vh;overflow:hidden;"></div>
      <div id="leaderboard-btn-container" style="margin-top:2vh;"></div>
    </div>
  </div>
</div>

<img id="gameover-bg" src="assets/backgrounds/gameOver_bg.png" alt="" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);object-fit:cover;z-index:-1;display:none;"/>
<img id="go-title" src="assets/text/text_gameOver.png" alt="Game Over Title" style="position:fixed;left:50%;top:75px;transform:translateX(-50%);height:auto;width:auto;z-index:9;display:none;"/>
<img id="menu-logo" src="assets/text/textLogo.png" alt="" style="position:fixed;left:calc(5vw - 125px);top:5px;width:45vw;height:auto;z-index:2;display:none;pointer-events:none;"/>
<img id="btn-worldmap" src="assets/buttons/button_worldMap.png" alt="World Map"
     style="position:fixed;left:50%;top:400px;transform:translateX(-50%);
            height:105px;width:auto;z-index:3;display:none;cursor:pointer;"/>
<div id="menu-shop-profile-container" style="position:fixed;left:50%;top:525px;transform:translateX(-50%);display:none;z-index:3;gap:10px;">
  <img id="btn-shop" src="assets/buttons/button_shop.png" alt="Shop"
       style="height:55px;width:auto;cursor:pointer;"/>
  <img id="btn-profile" src="assets/buttons/button_profile.png" alt="Profile"
       style="height:55px;width:auto;cursor:pointer;"/>
</div>
<img id="btn-leaderboard" src="assets/buttons/button_leaderboard.png" alt="Leaderboard"
     style="position:fixed;left:50%;top:525px;transform:translateX(-50%);
            height:55px;width:auto;z-index:3;display:none;cursor:pointer;"/>
<img id="btn-logout" src="assets/buttons/button_logout.png" alt="Logout"
     style="position:fixed;left:calc(50% - 70px);bottom:30px;transform:translateX(-50%);
            height:45px;width:auto;z-index:10;display:none;cursor:pointer;"/>
<img id="btn-continue" src="assets/buttons/button_continue.png" alt="Continue"
     style="position:fixed;left:50%;top:430px;transform:translateX(-50%);
            width:220px;height:auto;z-index:10;display:none;cursor:pointer;"/>
<img id="btn-next" src="assets/buttons/button_nextLevel.png" alt="Next Level"
     style="position:fixed;left:50%;top:55%;transform:translateX(-50%);
            width:auto;height:auto;z-index:10;display:none;cursor:pointer;"/>
<img id="btn-menu" src="assets/buttons/button_menu.png" alt="Menu"
     style="position:fixed;right:16px;bottom:16px;transform-origin: bottom right;transform: scale(0.5);
            width:auto;height:auto;z-index:10;display:none;cursor:pointer;"/>
<img id="btn-submit" src="assets/buttons/button_submitScore.png" alt="Submit Score"
     style="position:fixed;left:50%;top:335px;transform:translateX(-50%);
            width:154px;height:auto;z-index:10;display:none;cursor:pointer;"/>
<img id="btn-try" src="assets/buttons/button_tryAgain.png" alt="Try Again"
     style="position:fixed;left:50%;top:440px;transform:translateX(-50%);
            width:260px;height:auto;z-index:10;display:none;cursor:pointer;"/>
<img id="btn-worldmap-go" src="assets/buttons/button_worldMap.png" alt="World Map"
     style="position:fixed;left:50%;top:520px;transform:translateX(-50%);
            width:260px;height:auto;z-index:10;display:none;cursor:pointer;"/>
<img id="btn-quit" src="assets/buttons/button_quit.png" alt="Quit"
     style="position:fixed;left:calc(50% + 70px);bottom:30px;transform:translateX(-50%);
            height:45px;width:auto;z-index:10;display:none;cursor:pointer;"/>
<!-- Game Over Total Points (DOM element for debug outline support) -->
<div id="go-total-points" style="position:fixed;left:50%;transform:translateX(-50%);
     color:#FFD700;font-family:Arial,sans-serif;font-size:20px;text-align:center;
     text-shadow:2px 2px 4px #000;z-index:10;display:none;"></div>
<!-- Level Complete Text (DOM element for debug outline support) -->
<div id="level-complete-text" style="position:fixed;left:50%;top:30%;transform:translateX(-50%);
     max-width:95vw;color:#FFD700;font-family:Georgia,serif;font-size:clamp(28px, 5vh, 48px);text-align:center;
     text-shadow:3px 3px 6px #000, -1px -1px 2px #000;z-index:60;display:none;white-space:pre-line;
     line-height:1.3;max-height:20%;overflow:hidden;background:rgba(0,0,0,0.6);padding:15px 25px;border-radius:12px;"></div>
<!-- Game Over Button Container -->
<div id="go-btn-container" style="position:fixed;left:50%;transform:translateX(-50%);
     width:180px;display:none;flex-direction:column;align-items:center;gap:8px;z-index:10;">
</div>
<!-- Consequence Frame -->
<div id="consequence-container" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);display:none;z-index:100;">
  <div id="consequence-frame" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);height:calc(var(--vh, 1vh) * 60);width:calc(var(--vh, 1vh) * 60 * 1.5);">
    <!-- Frame image layer (aspect ratio 1536:1024 = 1.5:1) -->
    <img src="assets/frames/frame_consequence.png" style="position:absolute;inset:0;width:100%;height:100%;object-fit:fill;pointer-events:none;"/>
    <!-- Safe area for content (insets: top 18%, right 8%, bottom 10%, left 8%) -->
    <div id="consequence-safe-area" style="position:absolute;top:18%;left:8%;right:8%;bottom:10%;display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden;">
      <div id="consequence-text" style="color:#fff;font-family:Arial,sans-serif;font-size:clamp(16px, 3vh, 24px);text-align:center;text-shadow:2px 2px 4px #000;line-height:1.4;margin-bottom:2vh;"></div>
      <div id="consequence-stats" style="color:#fff;font-family:Arial,sans-serif;font-size:clamp(14px, 2.5vh, 20px);text-shadow:2px 2px 4px #000;margin-bottom:2vh;"></div>
      <div id="consequence-btn-container" style="display:flex;justify-content:center;width:100%;"></div>
    </div>
  </div>
</div>

<!-- Zone Complete Popup -->
<div id="zone-complete-container" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);display:none;z-index:100;background:rgba(0,0,0,0.7);">
  <div id="zone-complete-frame" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);height:calc(var(--vh, 1vh) * 60);width:calc(var(--vh, 1vh) * 60 * 1.5);opacity:0;">
    <!-- Frame image layer (aspect ratio 1536:1024 = 1.5:1) -->
    <img src="assets/frames/frame_consequence.png" style="position:absolute;inset:0;width:100%;height:100%;object-fit:fill;pointer-events:none;"/>
    <!-- Safe area for content -->
    <div id="zone-complete-safe-area" style="position:absolute;top:18%;left:8%;right:8%;bottom:10%;display:flex;flex-direction:column;align-items:center;justify-content:center;overflow:hidden;">
      <div id="zone-complete-title" style="color:#FFD700;font-family:Georgia,serif;font-size:clamp(28px, 5vh, 48px);text-align:center;text-shadow:2px 2px 4px #000;margin-bottom:1vh;">Zone Complete!</div>
      <div id="zone-complete-subtitle" style="color:#F5DEB3;font-family:Arial,sans-serif;font-size:clamp(16px, 3vh, 24px);text-align:center;text-shadow:2px 2px 4px #000;margin-bottom:3vh;"></div>
      <div id="zone-complete-btn-container" style="display:flex;justify-content:center;width:100%;"></div>
    </div>
  </div>
</div>

<!-- Zone Progress Tracker -->
<div id="zone-progress-tracker" style="position:fixed;left:50%;bottom:8%;transform:translateX(-50%);
     width:min(85vw, 840px);height:140px;display:none;z-index:45;overflow:visible;">
  <!-- Dark transparent background with padding for breathing room -->
  <div style="position:absolute;left:-5px;top:-5px;right:-5px;bottom:-5px;background:rgba(0,0,0,0.6);border-radius:8px;"></div>
  <svg id="progress-svg" width="100%" height="100%" style="overflow:visible;position:relative;">
    <!-- Paths and nodes will be drawn dynamically -->
  </svg>
  <!-- Trolley icon positioned absolutely within the container -->
  <img id="progress-trolley" src="assets/trolley_skins/trolley_preview_standard.png" alt="Trolley"
       style="position:absolute;width:60px;height:60px;object-fit:contain;
              filter:drop-shadow(0 0 8px rgba(255,215,0,0.6)) drop-shadow(0 4px 6px rgba(0,0,0,0.8));
              transition:left 1.2s ease-in-out, top 1.2s ease-in-out;pointer-events:none;"/>
</div>

<!-- New Scene Backgrounds -->
<img id="login-bg" src="assets/backgrounds/login_bg.png" alt="" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);object-fit:cover;z-index:99;display:none;"/>
<img id="worldmap-bg" src="assets/backgrounds/worldmap_bg.png" alt="" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);object-fit:cover;z-index:99;display:none;"/>
<img id="shop-bg" src="assets/backgrounds/shop_bg.png" alt="" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);object-fit:cover;z-index:99;display:none;"/>
<img id="profile-bg" src="assets/backgrounds/profile_bg.png" alt="" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);object-fit:cover;z-index:99;display:none;"/>

<!-- Points Icon -->
<img id="points-icon" src="assets/icons/icon_currency.png" alt="Points" title="Points" style="width:28px;height:28px;vertical-align:middle;display:none;"/>

<!-- Game HUD Elements -->
<div id="game-hud" style="position:fixed;top:0;left:0;right:0;display:none;z-index:48;padding:20px;">
  <div id="hud-left" style="position:absolute;left:20px;top:20px;">
    <div id="hud-health" style="color:#fff;font-family:Arial,sans-serif;font-size:20px;text-shadow:2px 2px 4px #000;margin-bottom:5px;">Health: 10</div>
    <div id="hud-points" style="color:#fff;font-family:Arial,sans-serif;font-size:20px;text-shadow:2px 2px 4px #000;">Points: 0</div>
  </div>
  <div id="hud-right" style="position:absolute;right:20px;top:20px;text-align:right;">
    <div id="hud-level" style="color:#fff;font-family:Arial,sans-serif;font-size:18px;text-shadow:2px 2px 4px #000;margin-bottom:6px;">Level: 1</div>
    <div id="hud-stage" style="color:#fff;font-family:Arial,sans-serif;font-size:18px;text-shadow:2px 2px 4px #000;margin-bottom:6px;">Stage: 1</div>
    <div id="hud-zone" style="color:#fff;font-family:Arial,sans-serif;font-size:16px;text-shadow:2px 2px 4px #000;">Zone Name</div>
  </div>
  <!-- Inventory icon button -->
  <div id="hud-inventory-btn" style="position:absolute;right:20px;top:90px;width:40px;height:40px;background:rgba(0,0,0,0.6);border:2px solid #FFD700;border-radius:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;" title="Inventory">
    <span style="font-size:20px;"></span>
  </div>
</div>

<!-- Game Inventory Overlay -->
<div id="game-inventory-overlay" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);background:rgba(0,0,0,0.8);display:none;z-index:150;align-items:center;justify-content:center;">
  <div id="game-inventory-panel" style="background:rgba(30,30,30,0.95);border:3px solid #FFD700;border-radius:12px;padding:20px;max-width:350px;width:90%;max-height:70vh;overflow-y:auto;">
    <h2 style="color:#FFD700;font-family:Georgia,serif;font-size:24px;text-align:center;margin:0 0 15px 0;text-shadow:2px 2px 4px #000;">Inventory</h2>
    <div id="game-inventory-items" style="display:flex;flex-direction:column;gap:10px;"></div>
    <div id="game-inventory-limit" style="color:#888;font-family:Arial;font-size:12px;text-align:center;margin-top:15px;">(0/3 items used this level)</div>
    <button id="game-inventory-close" style="display:block;margin:15px auto 0;padding:10px 24px;background:#FFD700;color:#000;border:none;border-radius:5px;cursor:pointer;font-family:Arial;font-size:14px;">Close</button>
  </div>
</div>

<!-- Question and Choice Frames for Gameplay - using CSS variables for responsive sizing -->
<div id="question-frame" style="position:fixed;left:50%;top:180px;transform:translateX(-50%);width:var(--question-frame-width, 750px);height:var(--question-frame-height, 225px);display:none;z-index:52;">
  <!-- Frame background layer -->
  <div style="position:absolute;inset:0;background:url('assets/frames/frame_question.png') center/100% 100% no-repeat;"></div>
  <!-- Safe area for text content (insets: top 18%, right 8%, bottom 18%, left 8%) -->
  <div id="question-safe-area" style="position:absolute;top:18%;left:8%;right:8%;bottom:18%;display:flex;align-items:center;justify-content:center;">
    <div id="question-text" style="color:#F5DEB3;font-family:Georgia,serif;font-size:var(--font-size-large, 24px);text-align:center;text-shadow:2px 2px 4px #000;line-height:1.4;"></div>
  </div>
</div>
<div id="choices-container" style="position:fixed;left:50%;top:430px;transform:translateX(-50%);display:none;z-index:54;width:min(900px, 95vw);">
  <div style="display:flex;justify-content:center;gap:clamp(15px, 3vw, 30px);flex-wrap:wrap;">
    <div id="choice-a-frame" style="position:relative;width:var(--choice-frame-width, 400px);height:var(--choice-frame-height, 160px);cursor:pointer;min-height:var(--min-touch-target, 44px);">
      <!-- Frame background layer -->
      <div style="position:absolute;inset:0;background:url('assets/frames/frame_choice.png') center/100% 100% no-repeat;"></div>
      <!-- Safe area for text content (insets: top 18%, right 9%, bottom 18%, left 9%) -->
      <div id="choice-a-safe-area" style="position:absolute;top:18%;left:9%;right:9%;bottom:18%;display:flex;align-items:center;justify-content:center;">
        <div id="choice-a-text" style="color:#F5DEB3;font-family:Georgia,serif;font-size:var(--font-size-base, 16px);text-align:center;text-shadow:1px 1px 3px #000;line-height:1.3;"></div>
      </div>
    </div>
    <div id="choice-b-frame" style="position:relative;width:var(--choice-frame-width, 400px);height:var(--choice-frame-height, 160px);cursor:pointer;min-height:var(--min-touch-target, 44px);">
      <!-- Frame background layer -->
      <div style="position:absolute;inset:0;background:url('assets/frames/frame_choice.png') center/100% 100% no-repeat;"></div>
      <!-- Safe area for text content (insets: top 18%, right 9%, bottom 18%, left 9%) -->
      <div id="choice-b-safe-area" style="position:absolute;top:18%;left:9%;right:9%;bottom:18%;display:flex;align-items:center;justify-content:center;">
        <div id="choice-b-text" style="color:#F5DEB3;font-family:Georgia,serif;font-size:var(--font-size-base, 16px);text-align:center;text-shadow:1px 1px 3px #000;line-height:1.3;"></div>
      </div>
    </div>
  </div>
</div>

<!-- Login Scene Elements -->
<div id="login-container" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);background:transparent;display:none;z-index:100;">
  <div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);text-align:center;">
    <img src="assets/text/textLogo.png" alt="Trolley Problem" style="width:min(550px, 90vw);height:auto;margin-bottom:0;filter:drop-shadow(2px 2px 4px #000);"/>
    <p style="color:#F5DEB3;font-family:Georgia,serif;font-size:18px;margin-top:5px;margin-bottom:30px;text-shadow:1px 1px 3px #000;">Make your choices. Face the consequences.</p>
    <div style="background:rgba(0,0,0,0.7);padding:30px;border-radius:10px;margin-bottom:20px;">
      <input id="login-username" type="text" placeholder="Enter your username" maxlength="16"
             style="width:250px;padding:12px;font-size:18px;border:none;border-radius:5px;margin-bottom:15px;text-align:center;"/>
      <br/>
      <button id="btn-login" style="width:200px;padding:12px;font-size:18px;background:#e94560;color:#fff;border:none;border-radius:5px;cursor:pointer;margin:5px;">
        Login / Create
      </button>
      <br/>
      <button id="btn-guest" style="width:200px;padding:12px;font-size:16px;background:#444;color:#fff;border:none;border-radius:5px;cursor:pointer;margin:5px;">
        Continue as Guest
      </button>
    </div>
  </div>
</div>

<!-- World Map Scene Elements -->
<div id="worldmap-container" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);background:transparent;display:none;z-index:100;">
  <h1 id="worldmap-title" style="position:absolute;left:30px;top:30px;color:#F5DEB3;font-family:Georgia,serif;font-size:32px;text-shadow:2px 2px 4px #000;">SELECT ZONE</h1>

  <!-- Zone Markers (left side of map) - using percentage positions for responsiveness -->
  <div id="zone-markers" style="position:absolute;left:5%;top:20%;width:45%;height:60%;">
    <!-- Connecting lines between zones -->
    <svg style="position:absolute;width:100%;height:100%;pointer-events:none;overflow:visible;">
      <!-- Line from Zone 1 to Zone 2 -->
      <line x1="22%" y1="58%" x2="47%" y2="35%" stroke="#4a3a20" stroke-width="4" stroke-linecap="round"/>
      <line x1="22%" y1="58%" x2="47%" y2="35%" stroke="#8B7355" stroke-width="2" stroke-linecap="round" stroke-dasharray="8,4"/>
      <!-- Line from Zone 2 to Zone 3 -->
      <line x1="47%" y1="33%" x2="72%" y2="15%" stroke="#4a3a20" stroke-width="4" stroke-linecap="round"/>
      <line x1="47%" y1="33%" x2="72%" y2="15%" stroke="#8B7355" stroke-width="2" stroke-linecap="round" stroke-dasharray="8,4"/>
      <!-- Line from Zone 3 to Zone 4 -->
      <line x1="72%" y1="15%" x2="92%" y2="35%" stroke="#4a3a20" stroke-width="4" stroke-linecap="round"/>
      <line x1="72%" y1="15%" x2="92%" y2="35%" stroke="#8B7355" stroke-width="2" stroke-linecap="round" stroke-dasharray="8,4"/>
    </svg>
    <!-- Zone 1: Starter Rails -->
    <div class="zone-marker" data-zone="1" style="position:absolute;left:15%;top:50%;width:min(100px, 20vw);height:min(100px, 20vw);cursor:pointer;transition:all 0.3s ease;filter:drop-shadow(0 4px 8px rgba(0,0,0,0.7));">
      <img src="assets/icons/icon_zone1.png" style="width:100%;height:100%;object-fit:contain;"/>
      <div class="zone-lock-overlay" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);border-radius:50%;display:flex;align-items:center;justify-content:center;">
        <img src="assets/icons/icon_locked.png" style="width:50%;height:50%;object-fit:contain;"/>
      </div>
    </div>
    <!-- Zone 2: Industrial Junction -->
    <div class="zone-marker" data-zone="2" style="position:absolute;left:40%;top:25%;width:min(100px, 20vw);height:min(100px, 20vw);cursor:pointer;transition:all 0.3s ease;filter:drop-shadow(0 4px 8px rgba(0,0,0,0.7));">
      <img src="assets/icons/icon_zone2.png" style="width:100%;height:100%;object-fit:contain;"/>
      <div class="zone-lock-overlay" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);border-radius:50%;display:flex;align-items:center;justify-content:center;">
        <img src="assets/icons/icon_locked.png" style="width:50%;height:50%;object-fit:contain;"/>
      </div>
    </div>
    <!-- Zone 3: City Terminal -->
    <div class="zone-marker" data-zone="3" style="position:absolute;left:65%;top:5%;width:min(100px, 20vw);height:min(100px, 20vw);cursor:pointer;transition:all 0.3s ease;filter:drop-shadow(0 4px 8px rgba(0,0,0,0.7));">
      <img src="assets/icons/icon_zone3.png" style="width:100%;height:100%;object-fit:contain;"/>
      <div class="zone-lock-overlay" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);border-radius:50%;display:flex;align-items:center;justify-content:center;">
        <img src="assets/icons/icon_locked.png" style="width:50%;height:50%;object-fit:contain;"/>
      </div>
    </div>
    <!-- Zone 4: Summit Line -->
    <div class="zone-marker" data-zone="4" style="position:absolute;left:85%;top:25%;width:min(100px, 20vw);height:min(100px, 20vw);cursor:pointer;transition:all 0.3s ease;filter:drop-shadow(0 4px 8px rgba(0,0,0,0.7));">
      <img src="assets/icons/icon_zone4.png" style="width:100%;height:100%;object-fit:contain;"/>
      <div class="zone-lock-overlay" style="display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.5);border-radius:50%;display:flex;align-items:center;justify-content:center;">
        <img src="assets/icons/icon_locked.png" style="width:50%;height:50%;object-fit:contain;"/>
      </div>
    </div>
  </div>

  <!-- Zone Detail Panel (right side) -->
  <div id="zone-detail-frame" style="position:absolute;right:30px;top:50%;transform:translateY(-50%);width:min(1000px, 50vw);height:min(1400px, calc(var(--vh, 1vh) * 92));display:none;">
    <!-- Dark background layer (75% of frame size) -->
    <div style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:75%;height:75%;background:rgba(15,15,25,0.95);border-radius:12px;"></div>
    <!-- Frame image layer (102% horizontal stretch) -->
    <img src="assets/frames/frame_zoneCard.png" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:102%;height:100%;object-fit:fill;pointer-events:none;"/>
    <!-- Safe area for content (insets: top 8%, right 34%, bottom 8%, left 34%) -->
    <div id="zone-detail-safe-area" style="position:absolute;top:8%;left:34%;right:34%;bottom:8%;display:flex;flex-direction:column;align-items:center;justify-content:center;text-align:center;">
      <h2 id="zone-detail-name" style="color:#FFD700;font-family:Georgia,serif;font-size:24px;margin:0 0 8px 0;text-shadow:1px 1px 2px #000;text-align:center;"></h2>
      <p id="zone-detail-desc" style="color:#F5DEB3;font-family:Arial;font-size:13px;margin:0 0 12px 0;line-height:1.3;text-align:center;"></p>

      <div style="margin-bottom:12px;text-align:left;">
        <span style="color:#aaa;font-family:Arial;font-size:11px;">DIFFICULTY</span>
        <div id="zone-detail-difficulty" style="color:#fff;font-family:Arial;font-size:14px;margin-top:3px;"></div>
      </div>

      <div style="margin-bottom:12px;text-align:left;">
        <span style="color:#aaa;font-family:Arial;font-size:11px;">CHOICES PER LEVEL</span>
        <div id="zone-detail-choices" style="color:#fff;font-family:Arial;font-size:14px;margin-top:3px;"></div>
      </div>

      <div style="margin-bottom:15px;text-align:left;">
        <span style="color:#aaa;font-family:Arial;font-size:11px;">PROGRESS</span>
        <div style="background:rgba(255,255,255,0.2);border-radius:5px;height:16px;overflow:hidden;margin-top:3px;">
          <div id="zone-detail-progress-bar" style="height:100%;background:#4CAF50;transition:width 0.3s;"></div>
        </div>
        <div id="zone-detail-progress-text" style="color:#fff;font-family:Arial;font-size:11px;margin-top:3px;"></div>
      </div>

      <div id="zone-difficulty-selector" style="margin-bottom:15px;text-align:center;display:none;">
        <span style="color:#aaa;font-family:Arial;font-size:11px;display:block;margin-bottom:6px;">SELECT DIFFICULTY</span>
        <div style="display:flex;justify-content:center;align-items:center;">
          <button class="difficulty-btn" data-difficulty="1">1</button>
          <button class="difficulty-btn" data-difficulty="2">2</button>
          <button class="difficulty-btn" data-difficulty="3">3</button>
        </div>
        <div id="zone-difficulty-multiplier" style="color:#FFD700;font-family:Arial;font-size:12px;margin-top:6px;">1.0x Multiplier</div>
      </div>

      <div id="zone-detail-locked" style="color:#e94560;font-family:Arial;font-size:13px;margin-bottom:12px;display:none;text-align:center;">
         Complete previous zone to unlock
      </div>

      <img id="btn-zone-start" src="assets/buttons/button_startGame.png" alt="Start" style="width:180px;height:auto;cursor:pointer;display:block;margin:10px auto 0 auto;"/>
    </div>
  </div>

  <!-- Back Button -->
  <img id="btn-worldmap-back" src="assets/buttons/button_menu.png" alt="Menu"
       style="position:absolute;left:20px;bottom:20px;width:auto;height:clamp(40px, 8vh, 60px);cursor:pointer;transition:transform 0.1s;"/>
</div>

<!-- Shop Scene Elements -->
<div id="shop-container" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);background:transparent;display:none;z-index:100;">
  <!-- Shop frame - centered -->
  <div id="shop-frame" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:calc(var(--vh, 1vh) * 90 * 0.64);height:calc(var(--vh, 1vh) * 90);">
    <!-- Frame image layer (aspect ratio 944:1472 = 0.64:1) -->
    <img src="assets/frames/frame_leaderboard.png" style="position:absolute;inset:0;width:100%;height:100%;object-fit:fill;pointer-events:none;"/>
    <!-- Safe area for content (insets: top 15%, right 15%, bottom 15%, left 15%) -->
    <div id="shop-safe-area" style="position:absolute;top:15%;left:15%;right:15%;bottom:15%;display:flex;flex-direction:column;align-items:center;overflow:hidden;">
      <h1 id="shop-title" style="color:#FFD700;font-family:Georgia,serif;font-size:clamp(24px, 5vh, 48px);margin:0;text-shadow:2px 2px 4px #000;">SHOP</h1>
      <div id="shop-points" style="color:#F5DEB3;font-family:Arial,sans-serif;font-size:clamp(14px, 2.5vh, 20px);margin-bottom:1vh;text-shadow:1px 1px 2px #000;"> 0 Points</div>
      <!-- Shop tabs -->
      <div id="shop-tabs" style="display:flex;gap:0;margin-bottom:1vh;width:100%;justify-content:center;">
        <button id="tab-cosmetics" style="padding:8px 20px;font-size:clamp(12px, 2vh, 16px);background:#FFD700;color:#000;border:none;border-radius:8px 8px 0 0;cursor:pointer;">Cosmetics</button>
        <button id="tab-consumables" style="padding:8px 20px;font-size:clamp(12px, 2vh, 16px);background:#555;color:#fff;border:none;border-radius:8px 8px 0 0;cursor:pointer;">Consumables</button>
      </div>
      <!-- Items area -->
      <div id="shop-items" style="width:100%;flex:1;display:flex;flex-direction:column;overflow:hidden;background:rgba(0,0,0,0.4);border-radius:0 8px 8px 8px;padding:10px;border-top:3px solid #FFD700;">
        <div id="shop-items-grid" style="flex:1;display:flex;flex-wrap:wrap;justify-content:center;align-content:flex-start;overflow:hidden;"></div>
        <div id="shop-pagination" style="display:flex;justify-content:center;align-items:center;gap:15px;padding-top:8px;border-top:1px solid rgba(255,255,255,0.2);margin-top:8px;flex-shrink:0;">
          <button id="shop-prev" style="padding:5px 12px;font-size:clamp(12px, 2vh, 16px);background:#FFD700;color:#000;border:none;border-radius:5px;cursor:pointer;"></button>
          <span id="shop-page-info" style="color:#F5DEB3;font-family:Arial;font-size:clamp(11px, 1.8vh, 14px);">Page 1 / 1</span>
          <button id="shop-next" style="padding:5px 12px;font-size:clamp(12px, 2vh, 16px);background:#FFD700;color:#000;border:none;border-radius:5px;cursor:pointer;"></button>
        </div>
      </div>
      <!-- Back button container -->
      <div id="shop-btn-container" style="margin-top:2vh;"></div>
    </div>
  </div>
</div>

<!-- Profile Scene Elements -->
<div id="profile-container" style="position:fixed;left:0;top:0;width:100vw;height:calc(var(--vh, 1vh) * 100);background:transparent;display:none;z-index:100;">
  <!-- Profile frame - centered -->
  <div id="profile-frame" style="position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);width:calc(var(--vh, 1vh) * 90 * 0.64);height:calc(var(--vh, 1vh) * 90);">
    <!-- Frame image layer (aspect ratio 944:1472 = 0.64:1) -->
    <img src="assets/frames/frame_leaderboard.png" style="position:absolute;inset:0;width:100%;height:100%;object-fit:fill;pointer-events:none;"/>
    <!-- Safe area for content (insets: top 15%, right 15%, bottom 15%, left 15%) -->
    <div id="profile-safe-area" style="position:absolute;top:15%;left:15%;right:15%;bottom:15%;display:flex;flex-direction:column;align-items:center;overflow:hidden;">
      <h1 id="profile-title" style="color:#FFD700;font-family:Georgia,serif;font-size:clamp(24px, 5vh, 48px);margin:0 0 1vh 0;text-shadow:2px 2px 4px #000;">PROFILE</h1>
      <!-- Tab bar -->
      <div id="profile-tabs" style="display:flex;gap:0;margin-bottom:1vh;width:100%;justify-content:center;">
        <button id="tab-stats" style="padding:8px 20px;font-size:clamp(12px, 2vh, 16px);background:#FFD700;color:#000;border:none;border-radius:8px 8px 0 0;cursor:pointer;">Stats</button>
        <button id="tab-inventory" style="padding:8px 20px;font-size:clamp(12px, 2vh, 16px);background:#555;color:#fff;border:none;border-radius:8px 8px 0 0;cursor:pointer;">Inventory</button>
        <button id="tab-achievements" style="padding:8px 20px;font-size:clamp(12px, 2vh, 16px);background:#555;color:#fff;border:none;border-radius:8px 8px 0 0;cursor:pointer;">Achievements</button>
      </div>
      <!-- Tab content area -->
      <div id="profile-tab-content" style="width:100%;flex:1;display:flex;flex-direction:column;overflow-y:auto;background:rgba(0,0,0,0.4);border-radius:0 8px 8px 8px;padding:10px;border-top:3px solid #FFD700;"></div>
      <!-- Back button container -->
      <div id="profile-btn-container" style="margin-top:2vh;"></div>
    </div>
  </div>
</div>

<!-- Item Bar for Level Scene -->
<div id="item-bar" style="position:fixed;left:10px;top:50%;transform:translateY(-50%);display:none;z-index:55;background:rgba(0,0,0,0.7);padding:8px;border-radius:8px;flex-direction:column;align-items:stretch;gap:6px;width:70px;">
  <span style="color:#fff;font-family:Arial;font-size:10px;text-align:center;">Items</span>
  <button id="item-hp-small" style="padding:6px 4px;background:#4CAF50;color:#fff;border:none;border-radius:4px;cursor:pointer;display:none;font-size:10px;">+3HP</button>
  <button id="item-hp-large" style="padding:6px 4px;background:#2196F3;color:#fff;border:none;border-radius:4px;cursor:pointer;display:none;font-size:10px;">+7HP</button>
  <button id="item-point-boost" style="padding:6px 4px;background:#FF9800;color:#fff;border:none;border-radius:4px;cursor:pointer;display:none;font-size:10px;">2xPts</button>
  <span id="items-used" style="color:#aaa;font-family:Arial;font-size:9px;text-align:center;">(0/3)</span>
</div>

<script>
// Set actual viewport height (accounts for taskbar/browser UI)
function setViewportHeight() {
  const vh = window.innerHeight * 0.01;
  document.documentElement.style.setProperty('--vh', `${vh}px`);
}
setViewportHeight();
window.addEventListener('resize', setViewportHeight);

// Mobile detection helper
function isMobileDevice() {
  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
         (window.matchMedia && window.matchMedia('(max-width: 900px)').matches && 'ontouchstart' in window);
}

// =====================================================
// ERROR BOUNDARIES - Safe scene transitions
// =====================================================
// Wraps scene transitions in try/catch to prevent white screens on errors.
// If a transition fails, logs the error and falls back to MainMenuScene.
const SceneTransition = {
  // Perform a safe scene transition with error handling
  goto(scene, targetScene, data = {}) {
    try {
      if (!scene || !scene.scene) {
        console.error('[SceneTransition] Invalid scene context');
        return false;
      }
      scene.scene.start(targetScene, data);
      return true;
    } catch (error) {
      console.error(`[SceneTransition] Failed to transition to ${targetScene}:`, error);
      // Attempt fallback to MainMenu if not already there
      if (targetScene !== 'MainMenuScene') {
        try {
          scene.scene.start('MainMenuScene');
        } catch (fallbackError) {
          console.error('[SceneTransition] Fallback to MainMenu also failed:', fallbackError);
          // Last resort: reload the page
          alert('An error occurred. The page will reload.');
          window.location.reload();
        }
      }
      return false;
    }
  }
};

// =====================================================
// ANALYTICS - Track player choices and behavior
// =====================================================
// Tracks player decisions, game events, and behavior patterns.
// Data is stored locally and can be exported for analysis.
// Useful for game balance insights and understanding player preferences.
const Analytics = {
  _events: [],
  _sessionId: 'session_' + Date.now(),
  _maxEvents: 1000, // Prevent unbounded growth

  // Track a player choice during gameplay
  trackChoice(data) {
    this._addEvent('choice', {
      zone: data.zone,
      level: data.level,
      stage: data.stage,
      prompt: data.prompt,
      chosenOption: data.chosenOption,
      chosenText: data.chosenText,
      pointsGained: data.pointsGained,
      hpChange: data.hpChange,
      healthAfter: data.healthAfter,
      timestamp: Date.now()
    });
  },

  // Track game events (level complete, game over, etc.)
  trackEvent(eventType, data = {}) {
    this._addEvent(eventType, {
      ...data,
      timestamp: Date.now()
    });
  },

  // Track item usage
  trackItemUse(itemId, itemValue, context) {
    this._addEvent('item_use', {
      itemId,
      itemValue,
      zone: context.zone,
      level: context.level,
      healthBefore: context.healthBefore,
      healthAfter: context.healthAfter,
      timestamp: Date.now()
    });
  },

  // Internal: add event with size management
  _addEvent(type, data) {
    this._events.push({
      type,
      sessionId: this._sessionId,
      ...data
    });
    // Trim old events if exceeding max
    if (this._events.length > this._maxEvents) {
      this._events = this._events.slice(-this._maxEvents);
    }
    this._persist();
  },

  // Persist to localStorage
  _persist() {
    try {
      localStorage.setItem('trolley_analytics', JSON.stringify(this._events));
    } catch (e) {
      // Storage full or unavailable - silently fail
      console.warn('[Analytics] Could not persist:', e.message);
    }
  },

  // Load existing analytics from storage
  load() {
    try {
      const data = localStorage.getItem('trolley_analytics');
      if (data) {
        this._events = JSON.parse(data);
      }
    } catch (e) {
      this._events = [];
    }
  },

  // Get summary statistics
  getSummary() {
    const choices = this._events.filter(e => e.type === 'choice');
    const byZone = {};
    choices.forEach(c => {
      if (!byZone[c.zone]) byZone[c.zone] = { total: 0, avgPoints: 0, avgHpChange: 0 };
      byZone[c.zone].total++;
      byZone[c.zone].avgPoints += c.pointsGained || 0;
      byZone[c.zone].avgHpChange += c.hpChange || 0;
    });
    // Calculate averages
    Object.keys(byZone).forEach(z => {
      if (byZone[z].total > 0) {
        byZone[z].avgPoints /= byZone[z].total;
        byZone[z].avgHpChange /= byZone[z].total;
      }
    });
    return {
      totalChoices: choices.length,
      totalSessions: new Set(this._events.map(e => e.sessionId)).size,
      byZone,
      itemsUsed: this._events.filter(e => e.type === 'item_use').length
    };
  },

  // Export all data as JSON (for external analysis)
  exportData() {
    return JSON.stringify(this._events, null, 2);
  },

  // Clear all analytics data
  clear() {
    this._events = [];
    localStorage.removeItem('trolley_analytics');
  }
};

// Initialize analytics on load
Analytics.load();

// =====================================================
// DEBUG MODE DOCUMENTATION
// =====================================================
// Debug mode provides visual inspection of UI elements during development.
//
// HOW TO USE:
// 1. Click and HOLD the magnifying glass button () in the top-right corner
// 2. While holding, colored outlines appear around different UI element types
// 3. Release to hide the outlines
//
// COLOR CODING:
// - Red:         Frames (containers with borders)
// - Lime:        Safe areas (content zones)
// - Cyan:        Buttons and tabs
// - Yellow:      Text elements and descriptions
// - Magenta:     Containers and content wrappers
// - Orange:      Logos
// - White:       Welcome messages and currency displays
// - Coral:       Titles and headings
// - Gold:        Zone-related elements
// - Violet:      Shop and profile elements
// - Spring Green: Progress indicators
// - Deep Sky Blue: Item elements
// - Light Salmon: Leaderboard elements
// - Tomato:      Consequence popups
// - Dodger Blue: HUD elements
// - Lime Green:  Game over elements
//
// ADDITIONAL DEBUG FEATURES:
// - On WorldMapScene: A second button () appears to unlock all zones/difficulties
// - Console logs prefixed with [DEBUG] indicate debug-related operations
//
// Debug button - hold to show outlines
(function() {
  const debugBtn = document.getElementById('debug-btn');
  if (debugBtn) {
    const enableDebug = () => document.body.classList.add('debug-active');
    const disableDebug = () => document.body.classList.remove('debug-active');

    // Mouse events
    debugBtn.addEventListener('mousedown', enableDebug);
    debugBtn.addEventListener('mouseup', disableDebug);
    debugBtn.addEventListener('mouseleave', disableDebug);

    // Touch events for mobile
    debugBtn.addEventListener('touchstart', (e) => { e.preventDefault(); enableDebug(); });
    debugBtn.addEventListener('touchend', disableDebug);
    debugBtn.addEventListener('touchcancel', disableDebug);
  }
})();

// Debug button - unlock all zones and difficulties
(function() {
  const unlockBtn = document.getElementById('debug-unlock-btn');
  if (unlockBtn) {
    unlockBtn.addEventListener('click', () => {
      const user = getUser();
      if (!user) return;

      // Unlock all zones by adding 5 completed levels per zone
      const zones = [1, 2, 3, 4];
      user.progress.completedLevels = [];
      zones.forEach(zoneId => {
        for (let level = 1; level <= 5; level++) {
          user.progress.completedLevels.push({
            zone: zoneId,
            level: level,
            score: 100,
            perfect: false
          });
        }
      });

      // Unlock all difficulties (set highest completed to 3 for each zone)
      user.progress.zoneCompletions = {};
      zones.forEach(zoneId => {
        user.progress.zoneCompletions[zoneId] = 3;
      });

      saveUser(user);
      console.log('[DEBUG] Unlocked all zones and difficulties');

      // Go to main menu and back to world map using scene's own methods
      if (window.game) {
        const worldMapScene = window.game.scene.getScene('WorldMapScene');
        if (worldMapScene && worldMapScene.scene) {
          // Hide world map container first like back button does
          const worldmapContainer = document.getElementById('worldmap-container');
          if (worldmapContainer) worldmapContainer.style.display = 'none';
          const detailPanel = document.getElementById('zone-detail-frame');
          if (detailPanel) detailPanel.style.display = 'none';

          setTimeout(() => {
            worldMapScene.scene.start('MainMenuScene');
            setTimeout(() => {
              const mainMenuScene = window.game.scene.getScene('MainMenuScene');
              if (mainMenuScene && mainMenuScene.scene) {
                mainMenuScene.scene.start('WorldMapScene');
              }
            }, 100);
          }, 50);
        }
      }
    });
  }
})();

// Leaderboard storage helpers
function getLeaderboard() {
  const data = localStorage.getItem('trolley_leaderboard');
  return data ? JSON.parse(data) : [];
}
function saveLeaderboard(list) {
  localStorage.setItem('trolley_leaderboard', JSON.stringify(list));
}

// =====================================================
// USER ACCOUNT SYSTEM
// =====================================================
function generateUserId() {
  return 'user_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
}

function createUser(username, isGuest = false) {
  const user = {
    userId: generateUserId(),
    username: username,
    isGuest: isGuest,
    createdAt: Date.now(),
    lastLogin: Date.now(),
    dataVersion: 1,
    progress: {
      currentZone: 1,
      completedLevels: [], // [{zone: 1, level: 1, score: 100, perfect: false}]
      highScores: {}, // {"1-1": 100, "1-2": 150}
      zoneCompletions: {} // {1: 1, 2: 0, 3: 0} - highest difficulty completed per zone
    },
    stats: {
      totalGames: 0,
      totalPoints: 0,
      totalDeaths: 0,
      choicesMade: 0,
      perfectLevels: 0,
      zonesCompleted: 0
    },
    inventory: {
      currency: 0,
      cosmetics: ['trolley_default'],
      consumables: {
        hp_small: 0,
        hp_large: 0,
        point_boost: 0
      }
    },
    equipped: {
      trolleyAppearance: 'trolley_default'
    },
    achievements: []
  };
  saveUser(user);
  return user;
}

// Legacy user functions - delegate to StateManager for caching and debouncing
function getUser() {
  return StateManager.getUser();
}

function saveUser(user) {
  // Update cache with the provided user object
  StateManager._userCache = user;
  StateManager._scheduleSave();
}

function clearUser() {
  StateManager.clear();
}

// =====================================================
// GAME CONSTANTS (Phase 1: Externalized magic numbers)
// =====================================================
const GAME_CONSTANTS = {
  // Health
  STARTING_HEALTH: 10,
  MAX_HEALTH: 20,

  // Difficulty multipliers
  DIFFICULTY_BASE_INCREMENT: 0.3,  // Each difficulty level adds this to zone modifier
  DIFFICULTY_MULTIPLIERS: [1.0, 1.3, 1.6],  // Convenience array for display

  // Bonuses
  PERFECT_LEVEL_BONUS: 0.5,  // 50% extra points for no damage
  MIN_POINTS_EARNED: 1,

  // Items
  MAX_ITEMS_PER_LEVEL: 3,

  // Shop
  ITEMS_PER_PAGE: 6,

  // UI Timing
  DEBOUNCE_SAVE_MS: 500,
  LAYOUT_RETRY_MS: 50,

  // Touch/Mobile
  MIN_TOUCH_TARGET_PX: 44,

  // Responsive breakpoints
  BREAKPOINTS: {
    MOBILE: 480,
    TABLET: 768,
    DESKTOP: 1024
  }
};

// =====================================================
// ZONE CONFIGURATION
// =====================================================
const ZoneConfig = [
  {
    id: 1,
    name: 'Starter Rails',
    description: 'Begin your journey on quiet suburban tracks.',
    choicesPerLevel: 3,
    levelsRequired: 5,
    difficultyMod: 1.0,
    unlockRequirement: 0, // always unlocked
    currencyBonus: 1.0,
    color: '#4CAF50',
    bgSuffix: 'level_01_background.png'
  },
  {
    id: 2,
    name: 'Industrial District',
    description: 'Navigate through the factory zone.',
    choicesPerLevel: 4,
    levelsRequired: 5,
    difficultyMod: 1.3,
    unlockRequirement: 5, // need 5 levels from zone 1
    currencyBonus: 1.05,
    color: '#FF9800',
    bgSuffix: 'level_01_background.png' // reuse until new assets
  },
  {
    id: 3,
    name: 'City Center',
    description: 'High stakes in the urban core.',
    choicesPerLevel: 5,
    levelsRequired: 5,
    difficultyMod: 1.6,
    unlockRequirement: 5, // need 5 levels from zone 2
    currencyBonus: 1.1,
    color: '#E91E63',
    bgSuffix: 'level_01_background.png' // reuse until new assets
  },
  {
    id: 4,
    name: 'Summit Line',
    description: 'Treacherous mountain passes await.',
    choicesPerLevel: 6,
    levelsRequired: 5,
    difficultyMod: 1.9,
    unlockRequirement: 5, // need 5 levels from zone 3
    currencyBonus: 1.15,
    color: '#00BCD4',
    bgSuffix: 'level_04_background.png'
  }
];

// =====================================================
// ZONE PROMPTS - Dilemmas/questions for each zone
// =====================================================
// These prompts can be edited externally via data/zone_prompts.json
// The PromptLoader will attempt to load from external JSON first,
// falling back to these inline prompts if loading fails.
//
// Each prompt has:
// - prompt: The question text displayed to the player
// - opts: Array of 2 options, each with:
//   - text: Option label
//   - pts: Points awarded for this choice
//   - hp: Health change (positive = heal, negative = damage)

// Inline fallback prompts (used if external JSON fails to load)
const ZonePromptsInline = {
  1: [ // Starter Rails
    {prompt:'Help child cross or save luggage?',opts:[{text:'Help child',pts:8,hp:0},{text:'Save luggage',pts:4,hp:0}]},
    {prompt:'Find water or conserve energy?',opts:[{text:'Find water',pts:3,hp:3},{text:'Conserve energy',pts:5,hp:0}]},
    {prompt:'Use first aid or press on?',opts:[{text:'Use first aid',pts:2,hp:4},{text:'Press on',pts:8,hp:-1}]},
    {prompt:'Steer on grass or hit barrier?',opts:[{text:'Grass',pts:6,hp:-2},{text:'Barrier',pts:12,hp:-5}]},
    {prompt:'Warn engineer or do nothing?',opts:[{text:'Warn',pts:10,hp:-1},{text:'Nothing',pts:0,hp:0}]},
    {prompt:'Take shortcut or stay on track?',opts:[{text:'Shortcut',pts:7,hp:-2},{text:'Stay safe',pts:3,hp:1}]},
    {prompt:'Help stranded motorist?',opts:[{text:'Help them',pts:6,hp:-1},{text:'Keep moving',pts:2,hp:0}]}
  ],
  2: [ // Industrial District
    {prompt:'Divert through factory or main line?',opts:[{text:'Factory',pts:12,hp:-3},{text:'Main line',pts:5,hp:-1}]},
    {prompt:'Warn workers or maintain speed?',opts:[{text:'Warn workers',pts:8,hp:0},{text:'Maintain speed',pts:15,hp:-4}]},
    {prompt:'Use emergency brake?',opts:[{text:'Pull brake',pts:4,hp:2},{text:'Coast through',pts:10,hp:-2}]},
    {prompt:'Take cargo shortcut?',opts:[{text:'Risk it',pts:14,hp:-4},{text:'Standard route',pts:6,hp:0}]},
    {prompt:'Help trapped worker?',opts:[{text:'Rescue',pts:10,hp:-2},{text:'Call for backup',pts:5,hp:0}]},
    {prompt:'Navigate steam vents?',opts:[{text:'Push through',pts:9,hp:-3},{text:'Wait',pts:3,hp:1}]},
    {prompt:'Cross unstable bridge?',opts:[{text:'Cross fast',pts:13,hp:-4},{text:'Find alternate',pts:5,hp:-1}]}
  ],
  3: [ // City Center
    {prompt:'Rush hour crossing?',opts:[{text:'Force through',pts:18,hp:-5},{text:'Wait for clear',pts:6,hp:0}]},
    {prompt:'Detour through park?',opts:[{text:'Park route',pts:12,hp:-2},{text:'Street route',pts:8,hp:-3}]},
    {prompt:'Emergency vehicle approaching!',opts:[{text:'Yield',pts:5,hp:0},{text:'Race ahead',pts:16,hp:-4}]},
    {prompt:'Construction zone ahead!',opts:[{text:'Plow through',pts:20,hp:-6},{text:'Detour',pts:8,hp:-1}]},
    {prompt:'School zone - children present!',opts:[{text:'Slow down',pts:4,hp:2},{text:'Maintain speed',pts:12,hp:-3}]},
    {prompt:'Traffic signal malfunction!',opts:[{text:'Go anyway',pts:15,hp:-4},{text:'Wait',pts:3,hp:1}]},
    {prompt:'Pedestrian on tracks!',opts:[{text:'Emergency stop',pts:6,hp:3},{text:'Swerve',pts:14,hp:-5}]}
  ],
  4: [ // Summit Line
    {prompt:'Avalanche warning - push through or wait?',opts:[{text:'Risk it',pts:22,hp:-6},{text:'Wait it out',pts:5,hp:0}]},
    {prompt:'Tracks frozen over - salt reserves low!',opts:[{text:'Use all salt',pts:10,hp:2},{text:'Slide through',pts:18,hp:-5}]},
    {prompt:'Stranded climbers spotted off the pass!',opts:[{text:'Stop to rescue',pts:14,hp:-3},{text:'Radio for help',pts:6,hp:0}]},
    {prompt:'Narrow cliff edge - rockslide blocking half!',opts:[{text:'Squeeze past',pts:20,hp:-7},{text:'Clear debris',pts:8,hp:-2}]},
    {prompt:'Blizzard reducing visibility to zero!',opts:[{text:'Push blind',pts:24,hp:-7},{text:'Emergency stop',pts:4,hp:1}]},
    {prompt:'Wooden trestle bridge groaning under weight!',opts:[{text:'Full speed across',pts:25,hp:-8},{text:'Slow crawl',pts:10,hp:-3}]},
    {prompt:'Passenger suffering altitude sickness!',opts:[{text:'Descend now',pts:8,hp:3},{text:'Continue to summit',pts:16,hp:-4}]}
  ]
};

// Prompt Loader - manages loading prompts from external JSON or inline fallback
const PromptLoader = {
  _prompts: null,
  _loaded: false,
  _source: 'inline', // 'inline' or 'external'

  // Get prompts (loads if not already loaded)
  getPrompts() {
    if (!this._prompts) {
      this._prompts = ZonePromptsInline;
    }
    return this._prompts;
  },

  // Attempt to load from external JSON file
  // Call this early in game initialization if you want to use external prompts
  async loadExternal(path = 'data/zone_prompts.json') {
    try {
      const response = await fetch(path);
      if (!response.ok) {
        throw new Error(`HTTP ${response.status}`);
      }
      const data = await response.json();

      // Convert external format to internal format
      const prompts = {};
      if (data.zones) {
        Object.keys(data.zones).forEach(zoneId => {
          prompts[zoneId] = data.zones[zoneId].prompts;
        });
      }

      // Validate that we have prompts for all zones
      if (Object.keys(prompts).length > 0) {
        this._prompts = prompts;
        this._source = 'external';
        this._loaded = true;
        console.log('[PromptLoader] Loaded prompts from external JSON');
        return true;
      }
    } catch (e) {
      console.log('[PromptLoader] External load failed, using inline prompts:', e.message);
    }

    // Fallback to inline
    this._prompts = ZonePromptsInline;
    this._source = 'inline';
    this._loaded = true;
    return false;
  },

  // Get the source of currently loaded prompts
  getSource() {
    return this._source;
  },

  // Get prompts for a specific zone
  getZonePrompts(zoneId) {
    const prompts = this.getPrompts();
    return prompts[zoneId] || [];
  }
};

// For backwards compatibility, ZonePrompts references the loader
const ZonePrompts = PromptLoader.getPrompts();

// =====================================================
// SHOP ITEMS CONFIGURATION
// =====================================================
const ShopItems = {
  cosmetics: [
    { id: 'trolley_default', name: 'Standard Trolley', price: 0, owned: true, color: '#888', preview: 'assets/trolley_skins/trolley_preview_standard.png' },
    { id: 'trolley_gold', name: 'Golden Trolley', price: 500, owned: false, color: '#FFD700', preview: 'assets/trolley_skins/trolley_preview_gold.png' },
    { id: 'trolley_fire', name: 'Flame Trolley', price: 750, owned: false, color: '#FF4500', preview: 'assets/trolley_skins/trolley_preview_fire.png' },
    { id: 'trolley_ice', name: 'Frost Trolley', price: 750, owned: false, color: '#00CED1', preview: 'assets/trolley_skins/trolley_preview_ice.png' },
    { id: 'trolley_neon', name: 'Neon Trolley', price: 1000, owned: false, color: '#FF00FF', preview: 'assets/trolley_skins/trolley_preview_neon.png' },
    { id: 'trolley_shadow', name: 'Shadow Trolley', price: 1500, owned: false, color: '#2F2F2F', preview: 'assets/trolley_skins/trolley_preview_shadow.png' }
  ],
  consumables: [
    {
      id: 'hp_small',
      name: 'Small Health Pack',
      price: 100,
      effect: '+3 HP',
      value: 3,
      type: 'health',
      buttonId: 'item-hp-small',
      buttonLabel: '+3 HP',
      buttonColor: '#4CAF50',
      icon: ''
    },
    {
      id: 'hp_large',
      name: 'Large Health Pack',
      price: 250,
      effect: '+7 HP',
      value: 7,
      type: 'health',
      buttonId: 'item-hp-large',
      buttonLabel: '+7 HP',
      buttonColor: '#2196F3',
      icon: ''
    },
    {
      id: 'point_boost',
      name: 'Point Booster',
      price: 200,
      effect: '2x Points (1 level)',
      value: 2,
      type: 'multiplier',
      buttonId: 'item-point-boost',
      buttonLabel: '2x Points',
      buttonColor: '#FF9800',
      icon: '',
      onePerLevel: true  // Can only use once per level
    }
  ]
};

// =====================================================
// ACHIEVEMENT DEFINITIONS
// =====================================================
// Achievement definitions with data-driven conditions
const AchievementDefs = [
  {
    id: 'first_game',
    name: 'First Steps',
    desc: 'Complete your first game',
    icon: '',
    condition: (user) => user.stats.totalGames >= 1
  },
  {
    id: 'zone1_complete',
    name: 'Starter Champion',
    desc: 'Complete Zone 1',
    icon: '',
    condition: (user) => {
      const zone = ZoneConfig.find(z => z.id === 1);
      return zone && user.progress.completedLevels.filter(l => l.zone === 1).length >= zone.levelsRequired;
    }
  },
  {
    id: 'zone2_complete',
    name: 'Industrial Expert',
    desc: 'Complete Zone 2',
    icon: '',
    condition: (user) => {
      const zone = ZoneConfig.find(z => z.id === 2);
      return zone && user.progress.completedLevels.filter(l => l.zone === 2).length >= zone.levelsRequired;
    }
  },
  {
    id: 'zone3_complete',
    name: 'City Master',
    desc: 'Complete Zone 3',
    icon: '',
    condition: (user) => {
      const zone = ZoneConfig.find(z => z.id === 3);
      return zone && user.progress.completedLevels.filter(l => l.zone === 3).length >= zone.levelsRequired;
    }
  },
  {
    id: 'perfect_level',
    name: 'Perfectionist',
    desc: 'Complete a level without taking damage',
    icon: '',
    condition: (user) => user.stats.perfectLevels >= 1
  },
  {
    id: 'high_roller',
    name: 'High Roller',
    desc: 'Earn 1000+ points',
    icon: '',
    condition: (user) => user.inventory.currency >= 1000
  },
  {
    id: 'collector',
    name: 'Collector',
    desc: 'Own 3 trolley cosmetics',
    icon: '',
    condition: (user) => user.inventory.cosmetics.length >= 3
  },
  {
    id: 'survivor',
    name: 'Survivor',
    desc: 'Survive with 1 HP',
    icon: '',
    condition: null  // Manually checked in GameOverScene
  }
];

// Data-driven achievement checking
function checkAchievements(user) {
  const earned = [];
  AchievementDefs.forEach(achievement => {
    if (achievement.condition &&
        !user.achievements.includes(achievement.id) &&
        achievement.condition(user)) {
      earned.push(achievement.id);
    }
  });
  return earned;
}

// Helper to calculate points earned
function calculatePointsEarned(score, zoneId, isPerfect) {
  const zone = ZoneConfig.find(z => z.id === zoneId) || ZoneConfig[0];
  let base = score; // 1:1 score to points
  base = Math.floor(base * zone.currencyBonus); // Zone bonus
  if (isPerfect) base = Math.floor(base * (1 + GAME_CONSTANTS.PERFECT_LEVEL_BONUS)); // Perfect bonus
  return Math.max(base, GAME_CONSTANTS.MIN_POINTS_EARNED); // Minimum points
}

// =====================================================
// UI MANAGER (Phase 2: Centralized DOM operations)
// =====================================================
const UIManager = {
  // Cached DOM element references
  _cache: {},

  // All element IDs that need to be managed
  _elementIds: [
    // Backgrounds
    'menu-bg', 'level-bg', 'login-bg', 'worldmap-bg', 'shop-bg', 'profile-bg', 'gameover-bg',
    // Containers
    'login-container', 'worldmap-container', 'shop-container', 'profile-container',
    'consequence-container', 'zone-complete-container', 'leaderboard-container',
    // Buttons
    'btn-worldmap', 'btn-shop', 'btn-leaderboard', 'btn-profile', 'btn-logout', 'btn-quit',
    'btn-continue', 'btn-next', 'btn-menu', 'btn-submit', 'btn-try', 'btn-worldmap-go',
    'btn-zone-start', 'btn-worldmap-back', 'btn-shop-back', 'btn-profile-back',
    // HUD & Gameplay
    'game-hud', 'hud-health', 'hud-points', 'hud-level', 'hud-stage', 'hud-zone',
    'question-frame', 'choices-container', 'question-text',
    'choice-a-frame', 'choice-a-text', 'choice-b-frame', 'choice-b-text',
    'item-bar', 'items-used',
    // Game Over
    'go-title', 'go-total-points', 'go-btn-container',
    // Menu
    'menu-logo', 'menu-welcome-display', 'menu-points-display',
    // Zone Detail
    'zone-detail-frame', 'zone-detail-name', 'zone-detail-desc',
    'zone-detail-difficulty', 'zone-detail-choices',
    'zone-detail-progress-bar', 'zone-detail-progress-text',
    'zone-difficulty-selector', 'zone-difficulty-multiplier', 'zone-detail-locked',
    // Consequence & Zone Complete
    'consequence-text', 'consequence-stats', 'consequence-btn-container',
    'zone-complete-frame', 'zone-complete-title', 'zone-complete-subtitle', 'zone-complete-btn-container',
    // Leaderboard
    'leaderboard-entries', 'leaderboard-btn-container',
    // Shop
    'shop-points', 'shop-items-grid', 'shop-page-info', 'shop-prev', 'shop-next',
    'tab-cosmetics', 'tab-consumables',
    // Profile
    'profile-content', 'achievements-content',
    // Zone Progress Tracker
    'zone-progress-tracker', 'progress-svg', 'progress-trolley'
  ],

  // Initialize cache at startup
  init() {
    this._elementIds.forEach(id => {
      this._cache[id] = document.getElementById(id);
    });
    // Also cache item buttons
    ShopItems.consumables.forEach(item => {
      this._cache[item.buttonId] = document.getElementById(item.buttonId);
    });
  },

  // Get element by ID (cached)
  get(id) {
    if (!this._cache[id]) {
      this._cache[id] = document.getElementById(id);
    }
    return this._cache[id];
  },

  // Hide all managed elements
  hideAll() {
    // Hide all backgrounds
    ['menu-bg', 'level-bg', 'login-bg', 'worldmap-bg', 'shop-bg', 'profile-bg', 'gameover-bg'].forEach(id => {
      const el = this.get(id);
      if (el) el.style.display = 'none';
    });

    // Hide all containers
    ['login-container', 'worldmap-container', 'shop-container', 'profile-container',
     'consequence-container', 'zone-complete-container', 'leaderboard-container', 'game-inventory-overlay', 'debug-unlock-btn',
     'menu-shop-profile-container'].forEach(id => {
      const el = this.get(id);
      if (el) el.style.display = 'none';
    });

    // Hide all buttons
    ['btn-worldmap', 'btn-shop', 'btn-leaderboard', 'btn-profile', 'btn-logout', 'btn-quit',
     'btn-continue', 'btn-next', 'btn-menu', 'btn-submit', 'btn-try', 'btn-worldmap-go'].forEach(id => {
      const el = this.get(id);
      if (el) {
        el.style.display = 'none';
        el.onclick = null;
      }
    });

    // Hide HUD & gameplay elements
    ['game-hud', 'question-frame', 'choices-container', 'item-bar', 'go-title', 'go-total-points',
     'menu-logo', 'menu-welcome-display', 'menu-points-display', 'zone-detail-frame', 'level-complete-text',
     'zone-progress-tracker', 'hud-inventory-btn'].forEach(id => {
      const el = this.get(id);
      if (el) el.style.display = 'none';
    });

    // Handle go-btn-container specially - restore buttons to body
    const goBtnContainer = this.get('go-btn-container');
    if (goBtnContainer) {
      ['btn-worldmap-go', 'btn-try', 'btn-submit', 'btn-menu'].forEach(id => {
        const btn = this.get(id);
        if (btn && btn.parentElement === goBtnContainer) {
          btn.style.display = 'none';
          btn.style.position = 'fixed';
          btn.onclick = null;
          document.body.appendChild(btn);
        }
      });
      goBtnContainer.style.display = 'none';
    }
  },

  // Show only specified elements
  showOnly(ids) {
    this.hideAll();
    ids.forEach(id => {
      const el = this.get(id);
      if (el) el.style.display = 'block';
    });
  },

  // Update HUD with batched values
  updateHUD(values) {
    if (values.health !== undefined) {
      const el = this.get('hud-health');
      if (el) el.textContent = 'Health: ' + values.health;
    }
    if (values.points !== undefined) {
      const el = this.get('hud-points');
      if (el) el.textContent = 'Points: ' + values.points;
    }
    if (values.level !== undefined) {
      const el = this.get('hud-level');
      if (el) el.textContent = 'Level: ' + values.level;
    }
    if (values.stage !== undefined) {
      const el = this.get('hud-stage');
      if (el) el.textContent = 'Stage: ' + values.stage;
    }
    if (values.zone !== undefined) {
      const el = this.get('hud-zone');
      if (el) {
        const zoneConfig = ZoneConfig.find(z => z.id === values.zone);
        if (zoneConfig) {
          el.textContent = zoneConfig.name;
          el.style.color = zoneConfig.color;
        }
      }
    }
  },

  // Show/hide question and choice frames
  showQuestionFrames(show) {
    const qf = this.get('question-frame');
    const cc = this.get('choices-container');
    if (qf) qf.style.display = show ? 'block' : 'none';
    if (cc) cc.style.display = show ? 'block' : 'none';
  },

  // Enable/disable choice frame interactions
  enableChoiceFrames(enabled) {
    ['choice-a-frame', 'choice-b-frame'].forEach(id => {
      const el = this.get(id);
      if (el) {
        el.style.pointerEvents = enabled ? 'auto' : 'none';
        el.style.opacity = enabled ? '1' : '0.6';
      }
    });
  }
};

// =====================================================
// ZONE PROGRESS TRACKER (Visual path through zones)
// =====================================================
const ZoneProgressTracker = {
  container: null,
  svg: null,
  trolleyImg: null,
  choices: [], // Array of 'A' or 'B' for each stage
  maxStages: 5,
  nodeRadius: 8,
  pathWidth: 3,
  renderScale: 1,    // Scale factor from render (for trolley positioning)
  renderOffsetY: 0,  // Y offset from render (for trolley positioning)
  colors: {
    path: '#B8860B',        // Dark gold for paths
    pathTaken: '#FFD700',   // Bright gold for taken path
    pathNotTaken: '#444',   // Grey for not-taken path
    node: '#B8860B',        // Dark gold for nodes
    nodeActive: '#FFD700',  // Bright gold for current node
    nodeFuture: '#666'      // Grey for future nodes
  },

  init() {
    this.container = document.getElementById('zone-progress-tracker');
    this.svg = document.getElementById('progress-svg');
    this.trolleyImg = document.getElementById('progress-trolley');
  },

  reset(maxStages = 5) {
    this.choices = [];
    this.maxStages = maxStages;
    // Reset transform values to defaults
    this.renderScale = 1;
    this.renderOffsetY = 0;
    // Only render if container is visible (has dimensions)
    if (this.container && this.container.offsetWidth > 0) {
      this.render();
    }
  },

  show() {
    if (this.container) {
      this.container.style.display = 'block';
      // Re-render now that container is visible and has dimensions
      this.render();
    }
  },

  hide() {
    if (this.container) this.container.style.display = 'none';
  },

  updateTrolleySkin() {
    if (!this.trolleyImg) return;
    const user = getUser();
    // Default to standard trolley
    let previewPath = 'assets/trolley_skins/trolley_preview_standard.png';
    if (user && user.inventory.equippedSkin) {
      const equipped = ShopItems.cosmetics.find(c => c.id === user.inventory.equippedSkin);
      if (equipped && equipped.preview) {
        previewPath = equipped.preview;
      }
    }
    this.trolleyImg.src = previewPath;
  },

  recordChoice(choice) {
    // choice should be 'A' or 'B'
    this.choices.push(choice);
    this.render();
    this.animateTrolley();
  },

  render() {
    if (!this.svg || !this.container) return;

    const width = this.container.offsetWidth || 600;
    const height = this.container.offsetHeight || 100;
    const internalPadding = 5; // 5px buffer inside the panel
    const segmentWidth = (width - 80) / this.maxStages;
    const baseForkHeight = segmentWidth * 0.3;

    // Clear existing SVG content
    this.svg.innerHTML = '';

    // PASS 1: Calculate all positions to find extents
    const positions = [];
    let calcX = 40;
    let calcY = height / 2; // Start at center
    let minY = calcY;
    let maxY = calcY;

    positions.push({ x: calcX, y: calcY, type: 'start' });

    const stagesToDraw = Math.min(this.choices.length + 1, this.maxStages);
    for (let i = 0; i < stagesToDraw; i++) {
      const startX = calcX;
      const startY = calcY;
      const endX = startX + segmentWidth;
      const topY = startY - baseForkHeight / 2;
      const bottomY = startY + baseForkHeight / 2;

      const hasChoice = i < this.choices.length;
      const choice = hasChoice ? this.choices[i] : null;

      // Track all Y positions including fork endpoints
      minY = Math.min(minY, topY);
      maxY = Math.max(maxY, bottomY);

      positions.push({
        stage: i,
        startX, startY, endX, topY, bottomY,
        choice, hasChoice,
        isCurrentFork: i === this.choices.length
      });

      if (hasChoice) {
        calcX = endX;
        calcY = choice === 'A' ? topY : bottomY;
      }
    }

    // PASS 2: Calculate scaling and offset
    const contentHeight = maxY - minY + (this.nodeRadius * 2); // Include node radius
    const availableHeight = height - (internalPadding * 2);
    const scale = contentHeight > availableHeight ? availableHeight / contentHeight : 1;

    // Calculate vertical offset to center the content
    const scaledContentHeight = contentHeight * scale;
    const contentCenterY = (minY + maxY) / 2;
    const targetCenterY = height / 2;
    const offsetY = targetCenterY - (contentCenterY * scale);

    // Helper function to transform Y coordinates
    const transformY = (y) => (y * scale) + offsetY;

    // PASS 3: Draw everything with transforms applied
    // Draw start node
    const startPos = positions[0];
    this.addNode(startPos.x, transformY(startPos.y), 0, this.colors.nodeActive);

    // Draw each stage
    for (let i = 1; i < positions.length; i++) {
      const p = positions[i];
      const { startX, startY, endX, topY, bottomY, choice, hasChoice, isCurrentFork, stage } = p;

      // Transform Y coordinates
      const tStartY = transformY(startY);
      const tTopY = transformY(topY);
      const tBottomY = transformY(bottomY);

      // Draw top path (Choice A)
      const topPathColor = isCurrentFork ? this.colors.pathNotTaken :
                          (choice === 'A' ? this.colors.pathTaken : this.colors.pathNotTaken);
      this.addPath(startX, tStartY, endX, tTopY, topPathColor, choice === 'A');

      // Draw bottom path (Choice B)
      const bottomPathColor = isCurrentFork ? this.colors.pathNotTaken :
                             (choice === 'B' ? this.colors.pathTaken : this.colors.pathNotTaken);
      this.addPath(startX, tStartY, endX, tBottomY, bottomPathColor, choice === 'B');

      // Draw end nodes
      const topNodeColor = isCurrentFork ? this.colors.nodeFuture :
                          (choice === 'A' ? this.colors.nodeActive : this.colors.pathNotTaken);
      const bottomNodeColor = isCurrentFork ? this.colors.nodeFuture :
                             (choice === 'B' ? this.colors.nodeActive : this.colors.pathNotTaken);

      this.addNode(endX, tTopY, stage + 1, topNodeColor);
      this.addNode(endX, tBottomY, stage + 1, bottomNodeColor);
    }

    // Store transform info for trolley positioning
    this.renderScale = scale;
    this.renderOffsetY = offsetY;

    // Position trolley at current location
    this.positionTrolley(false);
  },

  addPath(x1, y1, x2, y2, color, isChosen) {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    path.setAttribute('x1', x1);
    path.setAttribute('y1', y1);
    path.setAttribute('x2', x2);
    path.setAttribute('y2', y2);
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width', isChosen ? this.pathWidth + 1 : this.pathWidth);
    path.setAttribute('stroke-linecap', 'round');
    if (isChosen) {
      path.setAttribute('filter', 'drop-shadow(0 0 4px rgba(255,215,0,0.5))');
    }
    this.svg.appendChild(path);
  },

  addNode(x, y, stageIndex, color = this.colors.node) {
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', x);
    circle.setAttribute('cy', y);
    circle.setAttribute('r', this.nodeRadius);
    circle.setAttribute('fill', color);
    circle.setAttribute('stroke', '#000');
    circle.setAttribute('stroke-width', '2');
    this.svg.appendChild(circle);
  },

  getTrolleyPosition() {
    const width = this.container?.offsetWidth || 600;
    const height = this.container?.offsetHeight || 100;
    const centerY = height / 2;
    const segmentWidth = (width - 80) / this.maxStages;
    const baseForkHeight = segmentWidth * 0.3;

    let x = 40;
    let y = centerY;

    // Calculate position based on choices made (using base coordinates)
    for (let i = 0; i < this.choices.length; i++) {
      const startY = y;
      const topY = startY - baseForkHeight / 2;
      const bottomY = startY + baseForkHeight / 2;

      x += segmentWidth;
      y = this.choices[i] === 'A' ? topY : bottomY;
    }

    // Apply the same transform used in render()
    const scale = this.renderScale || 1;
    const offsetY = this.renderOffsetY || 0;
    const transformedY = (y * scale) + offsetY;

    return { x, y: transformedY };
  },

  positionTrolley(animate = false) {
    if (!this.trolleyImg || !this.container) return;

    const pos = this.getTrolleyPosition();
    // Use actual trolley size (may be different on mobile)
    const trolleySize = this.trolleyImg.offsetWidth || 80;

    // Position trolley centered on the node
    this.trolleyImg.style.left = (pos.x - trolleySize / 2) + 'px';
    this.trolleyImg.style.top = (pos.y - trolleySize / 2) + 'px';
  },

  animateTrolley() {
    // The CSS transition handles the animation
    // Just ensure we're positioning at the new location
    this.positionTrolley(true);
  }
};

// Scene layout definitions
const SCENE_LAYOUTS = {
  LoginScene: ['login-bg', 'login-container'],
  MainMenuScene: ['menu-bg', 'menu-logo', 'btn-worldmap', 'btn-shop', 'btn-leaderboard', 'btn-profile', 'btn-logout', 'btn-quit'],
  LevelScene: ['level-bg', 'game-hud', 'btn-menu', 'btn-quit'],
  GameOverScene: ['gameover-bg', 'go-title', 'go-total-points', 'go-btn-container'],
  LeaderboardScene: ['leaderboard-container'],
  WorldMapScene: ['worldmap-bg', 'worldmap-container'],
  ShopScene: ['shop-bg', 'shop-container'],
  ProfileScene: ['profile-bg', 'profile-container']
};

// Legacy function - delegates to UIManager for backwards compatibility
function hideAllContainers() {
  UIManager.hideAll();
}

// =====================================================
// STATE MANAGER (Phase 4: Debounced saves, cached state)
// =====================================================
// Default user data structure - used for validation and repair
const DEFAULT_USER_STRUCTURE = {
  userId: null,
  username: 'Guest',
  isGuest: true,
  createdAt: null,
  lastLogin: null,
  dataVersion: 1,
  progress: {
    currentZone: 1,
    completedLevels: [],
    highScores: {},
    zoneCompletions: {}
  },
  stats: {
    totalGames: 0,
    totalPoints: 0,
    totalDeaths: 0,
    choicesMade: 0,
    perfectLevels: 0,
    zonesCompleted: 0
  },
  inventory: {
    currency: 0,
    cosmetics: ['trolley_default'],
    consumables: {
      hp_small: 0,
      hp_large: 0,
      point_boost: 0
    }
  },
  equipped: {
    trolleyAppearance: 'trolley_default'
  },
  achievements: []
};

const StateManager = {
  _userCache: null,
  _saveTimeout: null,
  _pendingSave: false,

  // Validate and repair user data structure
  // Ensures all required fields exist with proper types
  _validateUser(user) {
    if (!user || typeof user !== 'object') {
      console.warn('[StateManager] Invalid user data - not an object');
      return null;
    }

    let wasRepaired = false;

    // Ensure required top-level fields
    if (!user.userId || typeof user.userId !== 'string') {
      console.warn('[StateManager] Missing or invalid userId');
      return null; // Can't repair missing userId - data is corrupt
    }

    // Validate and repair username
    if (typeof user.username !== 'string' || user.username.trim() === '') {
      user.username = DEFAULT_USER_STRUCTURE.username;
      wasRepaired = true;
    }

    // Validate dataVersion
    if (typeof user.dataVersion !== 'number') {
      user.dataVersion = DEFAULT_USER_STRUCTURE.dataVersion;
      wasRepaired = true;
    }

    // Validate and repair progress object
    if (!user.progress || typeof user.progress !== 'object') {
      user.progress = JSON.parse(JSON.stringify(DEFAULT_USER_STRUCTURE.progress));
      wasRepaired = true;
    } else {
      // Ensure progress sub-fields exist
      if (!Array.isArray(user.progress.completedLevels)) {
        user.progress.completedLevels = [];
        wasRepaired = true;
      }
      if (typeof user.progress.highScores !== 'object' || user.progress.highScores === null) {
        user.progress.highScores = {};
        wasRepaired = true;
      }
      if (typeof user.progress.zoneCompletions !== 'object' || user.progress.zoneCompletions === null) {
        user.progress.zoneCompletions = {};
        wasRepaired = true;
      }
      if (typeof user.progress.currentZone !== 'number') {
        user.progress.currentZone = 1;
        wasRepaired = true;
      }
    }

    // Validate and repair stats object
    if (!user.stats || typeof user.stats !== 'object') {
      user.stats = JSON.parse(JSON.stringify(DEFAULT_USER_STRUCTURE.stats));
      wasRepaired = true;
    } else {
      // Ensure all stat fields are numbers
      const statFields = ['totalGames', 'totalPoints', 'totalDeaths', 'choicesMade', 'perfectLevels', 'zonesCompleted'];
      statFields.forEach(field => {
        if (typeof user.stats[field] !== 'number') {
          user.stats[field] = 0;
          wasRepaired = true;
        }
      });
    }

    // Validate and repair inventory
    if (!user.inventory || typeof user.inventory !== 'object') {
      user.inventory = JSON.parse(JSON.stringify(DEFAULT_USER_STRUCTURE.inventory));
      wasRepaired = true;
    } else {
      if (typeof user.inventory.currency !== 'number') {
        user.inventory.currency = 0;
        wasRepaired = true;
      }
      if (!Array.isArray(user.inventory.cosmetics)) {
        user.inventory.cosmetics = ['trolley_default'];
        wasRepaired = true;
      }
      if (!user.inventory.consumables || typeof user.inventory.consumables !== 'object') {
        user.inventory.consumables = JSON.parse(JSON.stringify(DEFAULT_USER_STRUCTURE.inventory.consumables));
        wasRepaired = true;
      } else {
        // Ensure consumable counts are numbers
        ['hp_small', 'hp_large', 'point_boost'].forEach(item => {
          if (typeof user.inventory.consumables[item] !== 'number') {
            user.inventory.consumables[item] = 0;
            wasRepaired = true;
          }
        });
      }
    }

    // Validate and repair equipped
    if (!user.equipped || typeof user.equipped !== 'object') {
      user.equipped = JSON.parse(JSON.stringify(DEFAULT_USER_STRUCTURE.equipped));
      wasRepaired = true;
    } else if (typeof user.equipped.trolleyAppearance !== 'string') {
      user.equipped.trolleyAppearance = 'trolley_default';
      wasRepaired = true;
    }

    // Validate achievements array
    if (!Array.isArray(user.achievements)) {
      user.achievements = [];
      wasRepaired = true;
    }

    if (wasRepaired) {
      console.log('[StateManager] User data was repaired');
    }

    return user;
  },

  // Get user (from cache if available) with validation
  getUser() {
    if (this._userCache) {
      return this._userCache;
    }
    const data = localStorage.getItem('trolley_user');
    if (!data) return null;
    try {
      let user = JSON.parse(data);
      // Validate and repair if needed
      user = this._validateUser(user);
      if (!user) {
        console.error('[StateManager] User data validation failed - clearing corrupt data');
        localStorage.removeItem('trolley_user');
        return null;
      }
      this._userCache = user;
      return this._userCache;
    } catch(e) {
      console.error('[StateManager] Failed to parse user data:', e);
      return null;
    }
  },

  // Update user in cache (will debounce save)
  updateUser(updates) {
    if (!this._userCache) {
      this._userCache = this.getUser();
    }
    if (!this._userCache) return;

    // Apply updates
    if (typeof updates === 'function') {
      updates(this._userCache);
    } else {
      Object.assign(this._userCache, updates);
    }

    // Schedule debounced save
    this._scheduleSave();
  },

  // Force immediate save (for critical operations)
  saveNow() {
    if (this._saveTimeout) {
      clearTimeout(this._saveTimeout);
      this._saveTimeout = null;
    }
    this._doSave();
  },

  // Schedule a debounced save
  _scheduleSave() {
    this._pendingSave = true;
    if (this._saveTimeout) return;

    this._saveTimeout = setTimeout(() => {
      this._saveTimeout = null;
      this._doSave();
    }, GAME_CONSTANTS.DEBOUNCE_SAVE_MS);
  },

  // Perform the actual save
  _doSave() {
    if (!this._userCache || !this._pendingSave) return;
    this._userCache.lastLogin = Date.now();
    localStorage.setItem('trolley_user', JSON.stringify(this._userCache));
    this._pendingSave = false;
  },

  // Clear cache and user data
  clear() {
    this._userCache = null;
    if (this._saveTimeout) {
      clearTimeout(this._saveTimeout);
      this._saveTimeout = null;
    }
    this._pendingSave = false;
    localStorage.removeItem('trolley_user');
  },

  // Flush pending saves (call on page unload)
  flush() {
    if (this._pendingSave) {
      this._doSave();
    }
  },

  // Initialize with beforeunload handler
  init() {
    window.addEventListener('beforeunload', () => this.flush());
  }
};

// Initialize StateManager
StateManager.init();

// =====================================================
// BACKGROUND LOADER (Phase 4: Lazy loading)
// =====================================================
const BackgroundLoader = {
  _loaded: new Set(),
  _bgMap: {
    'LoginScene': ['login-bg'],
    'MainMenuScene': ['menu-bg'],
    'LevelScene': ['level-bg'],
    'GameOverScene': ['gameover-bg'],
    'LeaderboardScene': [],  // Uses dark background
    'WorldMapScene': ['worldmap-bg'],
    'ShopScene': ['shop-bg'],
    'ProfileScene': ['profile-bg']
  },

  // Preload backgrounds for a scene
  preload(sceneName) {
    const bgs = this._bgMap[sceneName];
    if (!bgs) return;

    bgs.forEach(id => {
      if (this._loaded.has(id)) return;

      const el = UIManager.get(id) || document.getElementById(id);
      if (el && el.tagName === 'IMG') {
        // Force load by accessing src
        const img = new Image();
        img.src = el.src;
        this._loaded.add(id);
      }
    });
  },

  // Preload adjacent scene backgrounds (for smooth transitions)
  preloadAdjacent(currentScene) {
    const adjacentScenes = {
      'LoginScene': ['MainMenuScene'],
      'MainMenuScene': ['WorldMapScene', 'ShopScene', 'ProfileScene', 'LeaderboardScene'],
      'WorldMapScene': ['MainMenuScene', 'LevelScene'],
      'LevelScene': ['GameOverScene', 'MainMenuScene'],
      'GameOverScene': ['MainMenuScene', 'WorldMapScene', 'LeaderboardScene'],
      'LeaderboardScene': ['MainMenuScene'],
      'ShopScene': ['MainMenuScene'],
      'ProfileScene': ['MainMenuScene']
    };

    const adjacent = adjacentScenes[currentScene];
    if (adjacent) {
      adjacent.forEach(scene => this.preload(scene));
    }
  }
};

// =====================================================
// EVENT TRACKER (Phase 4: Event listener cleanup)
// =====================================================
const EventTracker = {
  _listeners: new Map(), // Map<scene, Array<{element, type, handler}>>

  // Add event listener and track it for later cleanup
  add(scene, element, type, handler, options) {
    if (!element) return;

    element.addEventListener(type, handler, options);

    if (!this._listeners.has(scene)) {
      this._listeners.set(scene, []);
    }
    this._listeners.get(scene).push({ element, type, handler, options });
  },

  // Remove all listeners for a specific scene
  cleanup(scene) {
    const listeners = this._listeners.get(scene);
    if (!listeners) return;

    listeners.forEach(({ element, type, handler, options }) => {
      if (element) {
        element.removeEventListener(type, handler, options);
      }
    });

    this._listeners.delete(scene);
  },

  // Clear onclick handlers for elements (simpler approach for existing code)
  clearClickHandlers(elementIds) {
    elementIds.forEach(id => {
      const el = UIManager.get(id) || document.getElementById(id);
      if (el) el.onclick = null;
    });
  }
};

// =====================================================
// INPUT HANDLER (Phase 3: Unified touch/mouse support)
// =====================================================
const InputHandler = {
  // Add both click and touch handlers to an element
  addInteraction(element, callback, options = {}) {
    if (!element) return;

    const { preventDefault = true, stopPropagation = false } = options;

    // Unified handler for both mouse and touch
    const handleInteraction = (e) => {
      if (preventDefault) e.preventDefault();
      if (stopPropagation) e.stopPropagation();
      callback(e);
    };

    // Mouse events
    element.addEventListener('click', handleInteraction);

    // Touch events (with duplicate prevention)
    let touchHandled = false;
    element.addEventListener('touchend', (e) => {
      if (touchHandled) return;
      touchHandled = true;
      setTimeout(() => { touchHandled = false; }, 300);
      handleInteraction(e);
    }, { passive: false });

    return { element, handlers: { click: handleInteraction } };
  },

  // Add hover effects that work on touch (via touch start/end)
  addHoverEffect(element, onHover, onLeave) {
    if (!element) return;

    // Mouse hover
    element.addEventListener('mouseenter', onHover);
    element.addEventListener('mouseleave', onLeave);

    // Touch "hover" (press and hold)
    element.addEventListener('touchstart', onHover, { passive: true });
    element.addEventListener('touchend', onLeave, { passive: true });
    element.addEventListener('touchcancel', onLeave, { passive: true });
  },

  // Check if device supports touch
  hasTouch() {
    return 'ontouchstart' in window || navigator.maxTouchPoints > 0;
  },

  // Get pointer position from either mouse or touch event
  getPointerPosition(e) {
    if (e.touches && e.touches.length > 0) {
      return { x: e.touches[0].clientX, y: e.touches[0].clientY };
    }
    if (e.changedTouches && e.changedTouches.length > 0) {
      return { x: e.changedTouches[0].clientX, y: e.changedTouches[0].clientY };
    }
    return { x: e.clientX, y: e.clientY };
  },

  // Swipe gesture configuration
  swipeConfig: {
    minDistance: 80,      // Minimum swipe distance in pixels
    maxTime: 500,         // Maximum time for a swipe in ms
    maxRotation: 30,      // Maximum card rotation in degrees
    velocityThreshold: 0.5 // Velocity threshold for quick swipes
  },

  // Active swipe states (keyed by element)
  _swipeStates: new Map(),

  // Initialize swipe gesture on an element
  initSwipeGesture(element, callbacks) {
    if (!element) return;

    const state = {
      isActive: false,
      startX: 0,
      startY: 0,
      startTime: 0,
      currentX: 0,
      currentY: 0,
      velocityX: 0,
      lastMoveTime: 0
    };

    this._swipeStates.set(element, state);

    const handleStart = (e) => {
      const pos = this.getPointerPosition(e);
      state.isActive = true;
      state.startX = pos.x;
      state.startY = pos.y;
      state.currentX = pos.x;
      state.currentY = pos.y;
      state.startTime = Date.now();
      state.lastMoveTime = state.startTime;
      state.velocityX = 0;

      if (callbacks.onDragStart) {
        callbacks.onDragStart({ x: pos.x, y: pos.y });
      }
    };

    const handleMove = (e) => {
      if (!state.isActive) return;
      e.preventDefault();

      const pos = this.getPointerPosition(e);
      const now = Date.now();
      const timeDelta = now - state.lastMoveTime;

      // Calculate velocity
      if (timeDelta > 0) {
        state.velocityX = (pos.x - state.currentX) / timeDelta;
      }

      state.currentX = pos.x;
      state.currentY = pos.y;
      state.lastMoveTime = now;

      const deltaX = state.currentX - state.startX;
      const deltaY = state.currentY - state.startY;

      if (callbacks.onDrag) {
        callbacks.onDrag({
          deltaX,
          deltaY,
          velocityX: state.velocityX,
          progress: Math.min(Math.abs(deltaX) / this.swipeConfig.minDistance, 1)
        });
      }
    };

    const handleEnd = (e) => {
      if (!state.isActive) return;
      state.isActive = false;

      const pos = this.getPointerPosition(e);
      const deltaX = pos.x - state.startX;
      const deltaY = pos.y - state.startY;
      const elapsed = Date.now() - state.startTime;
      const distance = Math.abs(deltaX);

      // Determine if this was a valid swipe
      const isQuickSwipe = Math.abs(state.velocityX) > this.swipeConfig.velocityThreshold;
      const isLongSwipe = distance >= this.swipeConfig.minDistance && elapsed < this.swipeConfig.maxTime;
      const isValidSwipe = isQuickSwipe || isLongSwipe;

      if (isValidSwipe) {
        const direction = deltaX < 0 ? 'left' : 'right';
        if (direction === 'left' && callbacks.onSwipeLeft) {
          callbacks.onSwipeLeft({ deltaX, deltaY, velocityX: state.velocityX });
        } else if (direction === 'right' && callbacks.onSwipeRight) {
          callbacks.onSwipeRight({ deltaX, deltaY, velocityX: state.velocityX });
        }
      } else {
        // Incomplete swipe - snap back
        if (callbacks.onDragEnd) {
          callbacks.onDragEnd({ deltaX, deltaY, cancelled: true });
        }
      }
    };

    // Touch events
    element.addEventListener('touchstart', handleStart, { passive: true });
    element.addEventListener('touchmove', handleMove, { passive: false });
    element.addEventListener('touchend', handleEnd, { passive: true });
    element.addEventListener('touchcancel', handleEnd, { passive: true });

    // Mouse events for desktop testing
    element.addEventListener('mousedown', handleStart);
    element.addEventListener('mousemove', handleMove);
    element.addEventListener('mouseup', handleEnd);
    element.addEventListener('mouseleave', handleEnd);

    // Store handlers for cleanup
    element._swipeHandlers = { handleStart, handleMove, handleEnd };
  },

  // Remove swipe gesture from an element
  removeSwipeGesture(element) {
    if (!element || !element._swipeHandlers) return;

    const { handleStart, handleMove, handleEnd } = element._swipeHandlers;

    element.removeEventListener('touchstart', handleStart);
    element.removeEventListener('touchmove', handleMove);
    element.removeEventListener('touchend', handleEnd);
    element.removeEventListener('touchcancel', handleEnd);
    element.removeEventListener('mousedown', handleStart);
    element.removeEventListener('mousemove', handleMove);
    element.removeEventListener('mouseup', handleEnd);
    element.removeEventListener('mouseleave', handleEnd);

    this._swipeStates.delete(element);
    delete element._swipeHandlers;
  }
};

// =====================================================
// SWIPE CARD MANAGER (Portrait mode choice selection)
// =====================================================
const SwipeCardManager = {
  container: null,
  card: null,
  leftIndicator: null,
  rightIndicator: null,
  isVisible: false,
  choiceCallback: null,
  choiceA: null,
  choiceB: null,

  // Check if we should use swipe mode (portrait orientation on mobile)
  shouldUseSwipeMode() {
    const isPortrait = window.innerHeight > window.innerWidth;
    const isMobile = window.innerWidth <= 1200;
    return isPortrait && isMobile;
  },

  // Initialize the swipe card manager
  init() {
    // Remove existing container if present
    if (this.container) {
      this.container.remove();
    }

    // Create container
    this.container = document.createElement('div');
    this.container.id = 'swipe-card-container';
    this.container.style.cssText = `
      position: fixed;
      left: 50%;
      top: 45%;
      transform: translate(-50%, -50%);
      width: min(85vw, 350px);
      z-index: 60;
      display: none;
    `;

    // Create swipe indicators
    this.leftIndicator = document.createElement('div');
    this.leftIndicator.className = 'swipe-indicator left';
    this.leftIndicator.innerHTML = '';
    this.leftIndicator.style.cssText = `
      position: absolute;
      left: -50px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 36px;
      color: #e94560;
      opacity: 0;
      transition: opacity 0.15s ease;
      pointer-events: none;
    `;

    this.rightIndicator = document.createElement('div');
    this.rightIndicator.className = 'swipe-indicator right';
    this.rightIndicator.innerHTML = '';
    this.rightIndicator.style.cssText = `
      position: absolute;
      right: -50px;
      top: 50%;
      transform: translateY(-50%);
      font-size: 36px;
      color: #4ecdc4;
      opacity: 0;
      transition: opacity 0.15s ease;
      pointer-events: none;
    `;

    // Create the card
    this.card = document.createElement('div');
    this.card.id = 'swipe-card';
    this.card.style.cssText = `
      width: 100%;
      background: rgba(20, 20, 30, 0.95);
      border: 3px solid #FFD700;
      border-radius: 15px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
      cursor: grab;
      user-select: none;
      -webkit-user-select: none;
    `;

    this.container.appendChild(this.leftIndicator);
    this.container.appendChild(this.rightIndicator);
    this.container.appendChild(this.card);
    document.body.appendChild(this.container);

    // Setup swipe gesture
    this._setupSwipeGesture();

    // Listen for orientation changes
    window.addEventListener('resize', () => this._handleOrientationChange());
    window.addEventListener('orientationchange', () => this._handleOrientationChange());
  },

  // Create the card content
  // Default border color for reset
  defaultBorderColor: '#FFD700',

  _createCardContent(choiceA, choiceB) {
    const formatStats = (opt) => {
      const pts = (opt.pts >= 0 ? '+' : '') + opt.pts + ' pts';
      const hp = (opt.hp >= 0 ? '+' : '') + opt.hp + ' HP';
      return `(${pts}, ${hp})`;
    };

    // New side-by-side layout
    return `
      <div class="swipe-choices-row" style="display: flex; gap: 8px;">
        <div class="swipe-choice-section left" style="
          flex: 1;
          padding: 10px 8px;
          border-radius: 8px;
          background: rgba(255, 255, 255, 0.05);
          border-left: 3px solid #e94560;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
        ">
          <div class="swipe-direction-label" style="
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            color: #e94560;
            display: flex;
            align-items: center;
            gap: 4px;
          "><span class="arrow" style="font-size: 18px;"></span> LEFT</div>
          <div class="swipe-choice-text" style="
            color: #F5DEB3;
            font-family: Georgia, serif;
            font-size: 12px;
            line-height: 1.3;
            margin-bottom: 6px;
            flex: 1;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
          ">${choiceA.text}</div>
          <div class="swipe-choice-stats" style="
            color: #FFD700;
            font-size: 10px;
            font-family: Arial, sans-serif;
          ">${formatStats(choiceA)}</div>
        </div>

        <div class="swipe-choice-section right" style="
          flex: 1;
          padding: 10px 8px;
          border-radius: 8px;
          background: rgba(255, 255, 255, 0.05);
          border-right: 3px solid #4ecdc4;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
        ">
          <div class="swipe-direction-label" style="
            font-size: 11px;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 6px;
            color: #4ecdc4;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 4px;
          ">RIGHT <span class="arrow" style="font-size: 18px;"></span></div>
          <div class="swipe-choice-text" style="
            color: #F5DEB3;
            font-family: Georgia, serif;
            font-size: 12px;
            line-height: 1.3;
            margin-bottom: 6px;
            flex: 1;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
          ">${choiceB.text}</div>
          <div class="swipe-choice-stats" style="
            color: #FFD700;
            font-size: 10px;
            font-family: Arial, sans-serif;
          ">${formatStats(choiceB)}</div>
        </div>
      </div>
    `;
  },

  // Setup swipe gesture handling
  _setupSwipeGesture() {
    InputHandler.initSwipeGesture(this.card, {
      onDragStart: () => {
        this.card.style.transition = 'none';
        this.card.style.cursor = 'grabbing';
      },

      onDrag: (data) => {
        const { deltaX, progress } = data;
        const maxRotation = InputHandler.swipeConfig.maxRotation;
        const rotation = (deltaX / 200) * maxRotation;
        const clampedRotation = Math.max(-maxRotation, Math.min(maxRotation, rotation));

        this.card.style.transform = `translateX(${deltaX}px) rotate(${clampedRotation}deg)`;

        // Tint border color based on swipe direction
        if (deltaX < -20) {
          // Swiping left - red border
          this.card.style.borderColor = '#e94560';
          if (this.leftIndicator) this.leftIndicator.style.opacity = Math.min(progress, 1);
          if (this.rightIndicator) this.rightIndicator.style.opacity = 0;
        } else if (deltaX > 20) {
          // Swiping right - blue/teal border
          this.card.style.borderColor = '#4ecdc4';
          if (this.rightIndicator) this.rightIndicator.style.opacity = Math.min(progress, 1);
          if (this.leftIndicator) this.leftIndicator.style.opacity = 0;
        } else {
          // Neutral - reset to default gold
          this.card.style.borderColor = this.defaultBorderColor;
          if (this.leftIndicator) this.leftIndicator.style.opacity = 0;
          if (this.rightIndicator) this.rightIndicator.style.opacity = 0;
        }
      },

      onDragEnd: (data) => {
        // Snap back animation and reset border color
        this.card.style.transition = 'transform 0.2s ease-out, border-color 0.15s ease';
        this.card.style.transform = 'translateX(0) rotate(0deg)';
        this.card.style.borderColor = this.defaultBorderColor;
        this.card.style.cursor = 'grab';
        if (this.leftIndicator) this.leftIndicator.style.opacity = 0;
        if (this.rightIndicator) this.rightIndicator.style.opacity = 0;
      },

      onSwipeLeft: (data) => {
        this._handleSwipe('left', data);
      },

      onSwipeRight: (data) => {
        this._handleSwipe('right', data);
      }
    });
  },

  // Handle a completed swipe
  _handleSwipe(direction, data) {
    // Exit animation
    this.card.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';

    if (direction === 'left') {
      this.card.style.transform = 'translateX(-150vw) rotate(-30deg)';
      this.leftIndicator.style.opacity = 1;
    } else {
      this.card.style.transform = 'translateX(150vw) rotate(30deg)';
      this.rightIndicator.style.opacity = 1;
    }
    this.card.style.opacity = '0';

    // Trigger callback after animation
    setTimeout(() => {
      // Left = Choice A (index 0), Right = Choice B (index 1)
      const choiceIndex = direction === 'left' ? 0 : 1;
      if (this.choiceCallback) {
        this.choiceCallback(choiceIndex);
      }
      this.hide();
    }, 300);
  },

  // Show the swipe card with choices
  show(choiceA, choiceB, callback) {
    if (!this.container) {
      this.init();
    }

    this.choiceA = choiceA;
    this.choiceB = choiceB;
    this.choiceCallback = callback;

    // Reset card state
    this.card.style.transition = 'none';
    this.card.style.transform = 'translateX(0) rotate(0deg)';
    this.card.style.opacity = '1';
    this.leftIndicator.style.opacity = 0;
    this.rightIndicator.style.opacity = 0;

    // Populate content
    this.card.innerHTML = this._createCardContent(choiceA, choiceB);

    // Show container
    this.container.style.display = 'block';
    this.isVisible = true;

    // Force reflow before enabling transitions
    this.card.offsetHeight;
    this.card.style.transition = 'transform 0.1s ease-out';
  },

  // Hide the swipe card
  hide() {
    if (this.container) {
      this.container.style.display = 'none';
    }
    this.isVisible = false;
    this.choiceCallback = null;
  },

  // Handle orientation change
  _handleOrientationChange() {
    // If we're no longer in swipe mode but card is visible, hide it
    if (!this.shouldUseSwipeMode() && this.isVisible) {
      this.hide();
    }
  },

  // Cleanup
  destroy() {
    if (this.card) {
      InputHandler.removeSwipeGesture(this.card);
    }
    if (this.container) {
      this.container.remove();
      this.container = null;
    }
    this.card = null;
    this.leftIndicator = null;
    this.rightIndicator = null;
    this.isVisible = false;
  }
};

// =====================================================
// LOGIN SCENE
// =====================================================
class LoginScene extends Phaser.Scene {
  constructor() { super('LoginScene'); }

  create() {
    // Hide all other DOM elements
    hideAllContainers();
    const domBg = document.getElementById('menu-bg'); if (domBg) domBg.style.display = 'none';
    const domLogo = document.getElementById('menu-logo'); if (domLogo) domLogo.style.display = 'none';
    const levelBg = document.getElementById('level-bg'); if (levelBg) levelBg.style.display = 'none';
    const leaderboardBg = document.getElementById('leaderboard-container'); if (leaderboardBg) leaderboardBg.style.display = 'none';
    const gameOverBg = document.getElementById('gameover-bg'); if (gameOverBg) gameOverBg.style.display = 'none';
    const consBg = document.getElementById('consequence-container'); if (consBg) consBg.style.display = 'none';
    const goTitle = document.getElementById('go-title'); if (goTitle) goTitle.style.display = 'none';

    // Hide all buttons
    const buttons = ['btn-worldmap', 'btn-leaderboard', 'btn-shop', 'btn-profile', 'btn-logout', 'btn-continue', 'btn-next', 'btn-menu', 'btn-submit', 'btn-try', 'btn-worldmap-go', 'btn-quit'];
    buttons.forEach(id => {
      const btn = document.getElementById(id);
      if (btn) { btn.style.display = 'none'; btn.onclick = null; }
    });

    // Show login background and container
    const loginBg = document.getElementById('login-bg');
    if (loginBg) loginBg.style.display = 'block';
    const loginContainer = document.getElementById('login-container');
    if (loginContainer) loginContainer.style.display = 'block';

    // Setup login button
    const btnLogin = document.getElementById('btn-login');
    const usernameInput = document.getElementById('login-username');

    if (btnLogin) {
      btnLogin.onclick = () => {
        const username = usernameInput ? usernameInput.value.trim() : '';
        if (username.length < 1) {
          alert('Please enter a username (1-16 characters)');
          return;
        }
        // Check if user exists or create new
        let user = getUser();
        if (user && user.username === username) {
          // Existing user logging back in
          saveUser(user);
        } else {
          // Create new account
          user = createUser(username, false);
        }
        loginContainer.style.display = 'none';
        this.scene.start('MainMenuScene');
      };
    }

    // Setup guest button
    const btnGuest = document.getElementById('btn-guest');
    if (btnGuest) {
      btnGuest.onclick = () => {
        const guestId = 'Guest_' + Math.random().toString(36).substr(2, 6).toUpperCase();
        const user = createUser(guestId, true);
        loginContainer.style.display = 'none';
        this.scene.start('MainMenuScene');
      };
    }

    // Allow Enter key to submit
    if (usernameInput) {
      usernameInput.onkeydown = (e) => {
        if (e.key === 'Enter' && btnLogin) btnLogin.click();
      };
      usernameInput.value = '';
      usernameInput.focus();
    }
  }
}

class MainMenuScene extends Phaser.Scene {
  constructor() { super('MainMenuScene'); }
  create() {
    // Hide all containers first
    hideAllContainers();

    // Hide swipe card from portrait mode gameplay
    SwipeCardManager.hide();

    const domBg = document.getElementById('menu-bg'); if (domBg) domBg.style.display = 'block';
    const domLogo = document.getElementById('menu-logo'); if (domLogo) domLogo.style.display = 'block';
    // Hide level background when on main menu
    const levelBg = document.getElementById('level-bg'); if (levelBg) levelBg.style.display = 'none';
    const leaderboardBg = document.getElementById('leaderboard-container'); if (leaderboardBg) leaderboardBg.style.display = 'none';
    const gameOverBg = document.getElementById('gameover-bg'); if (gameOverBg) gameOverBg.style.display='none';
    document.body.style.backgroundColor = '';
    const consBgHideGO = document.getElementById('consequence-container'); if (consBgHideGO) consBgHideGO.style.display='none';
    const goTitleHideMM = document.getElementById('go-title'); if (goTitleHideMM) goTitleHideMM.style.display='none';

    // Ensure menu button is hidden on main menu (we only show it in Level/GameOver)
    const domMenuBtnMM = document.getElementById('btn-menu');
    if (domMenuBtnMM) { domMenuBtnMM.style.display='none'; domMenuBtnMM.onclick=null; }

    // Hide Game Over DOM buttons by default on menu
    const btnSubmitImg = document.getElementById('btn-submit'); if (btnSubmitImg) { btnSubmitImg.style.display='none'; btnSubmitImg.onclick=null; }
    const btnTryImg = document.getElementById('btn-try'); if (btnTryImg) { btnTryImg.style.display='none'; btnTryImg.onclick=null; }
    const btnWorldMapGoMM = document.getElementById('btn-worldmap-go'); if (btnWorldMapGoMM) { btnWorldMapGoMM.style.display='none'; btnWorldMapGoMM.onclick=null; }
    const btnNextMM = document.getElementById('btn-next'); if (btnNextMM) { btnNextMM.style.display='none'; btnNextMM.onclick=null; }
    const btnContinue = document.getElementById('btn-continue'); if (btnContinue) { btnContinue.style.display='none'; btnContinue.onclick=null; }

    // Get user data for display
    const user = getUser();

    // Display welcome message (left side, below title logo with buffer)
    if (user) {
      // Create or get DOM-based welcome display (well below logo bottom edge)
      let welcomeDisplay = document.getElementById('menu-welcome-display');
      if (!welcomeDisplay) {
        welcomeDisplay = document.createElement('div');
        welcomeDisplay.id = 'menu-welcome-display';
        document.body.appendChild(welcomeDisplay);
      }
      welcomeDisplay.style.cssText = 'position:fixed;left:calc(5vw + 80px);top:520px;color:#F5DEB3;font-family:Georgia,serif;font-size:22px;z-index:10;text-shadow:2px 2px 4px #000;';
      welcomeDisplay.textContent = `Welcome, ${user.username}!`;
      welcomeDisplay.style.display = 'block';

      // Create or get DOM-based points display with icon (below welcome)
      let pointsDisplay = document.getElementById('menu-points-display');
      if (!pointsDisplay) {
        pointsDisplay = document.createElement('div');
        pointsDisplay.id = 'menu-points-display';
        document.body.appendChild(pointsDisplay);
      }
      pointsDisplay.style.cssText = 'position:fixed;left:calc(5vw + 80px);top:555px;color:#FFD700;font-family:Arial;font-size:18px;z-index:10;text-shadow:2px 2px 3px #000;';
      pointsDisplay.innerHTML = `<img src="assets/icons/icon_currency.png" alt="Points" title="Points" style="width:22px;height:22px;vertical-align:middle;margin-right:6px;"/>${user.inventory.currency} Points`;
      pointsDisplay.style.display = 'block';
    }

    // Show World Map button (centered, larger - main action)
    const btnWorldMap = document.getElementById('btn-worldmap');
    if (btnWorldMap) {
      btnWorldMap.style.display = 'block';
      btnWorldMap.onclick = () => {
        btnWorldMap.classList.add('btn-pressed');
        setTimeout(() => {
          btnWorldMap.classList.remove('btn-pressed');
          this.scene.start('WorldMapScene');
        }, 150);
      };
    }

    // Show Leaderboard, Shop, Profile buttons in a row (smaller, above World Map)
    const btnLeaderboard = document.getElementById('btn-leaderboard');
    if (btnLeaderboard) {
      btnLeaderboard.style.display = 'block';
      btnLeaderboard.onclick = () => this.scene.start('LeaderboardScene');
    }

    // Show shop/profile container and buttons
    const shopProfileContainer = document.getElementById('menu-shop-profile-container');
    if (shopProfileContainer) shopProfileContainer.style.display = 'flex';

    const btnShop = document.getElementById('btn-shop');
    if (btnShop) {
      btnShop.style.display = 'block';
      btnShop.onclick = () => this.scene.start('ShopScene');
    }

    const btnProfile = document.getElementById('btn-profile');
    if (btnProfile) {
      btnProfile.style.display = 'block';
      btnProfile.onclick = () => this.scene.start('ProfileScene');
    }

    // Show Logout button at bottom (left of Quit)
    const btnLogout = document.getElementById('btn-logout');
    if (btnLogout && user) {
      btnLogout.style.display = 'block';
      btnLogout.style.height = '53px'; // Match quit button's scaled height
      btnLogout.style.width = 'auto';
      btnLogout.onclick = () => {
        clearUser();
        this.scene.start('LoginScene');
      };
    }

    // Show Quit button at bottom (right of Logout) - half size for main menu
    // Hidden on mobile since window.close() doesn't work in browsers
    const btnQuitMM = document.getElementById('btn-quit');
    if (btnQuitMM) {
      if (isMobileDevice()) {
        btnQuitMM.style.display = 'none';
      } else {
        btnQuitMM.style.display = 'block';
        btnQuitMM.style.position = 'fixed';
        btnQuitMM.style.left = 'calc(50% + 70px)';
        btnQuitMM.style.bottom = '30px';
        btnQuitMM.style.top = '';
        btnQuitMM.style.height = 'auto'; // Use natural height
        btnQuitMM.style.transformOrigin = 'bottom center'; // Align by bottom edge
        btnQuitMM.style.transform = 'translateX(-50%) scale(0.5)'; // Half size = 53px
        btnQuitMM.style.zIndex = '10';
        btnQuitMM.onclick = () => window.close();
      }
    }
  }
}

class LevelScene extends Phaser.Scene {
  constructor() { super('LevelScene'); }
  init() {
    if (this.registry.get('health')===undefined) this.registry.set('health',10);
    // Load points from user's persistent balance (don't reset)
    const user = getUser();
    const persistentPoints = user ? user.inventory.currency : 0;
    if (this.registry.get('points')===undefined) this.registry.set('points', persistentPoints);
    if (this.registry.get('level')===undefined) this.registry.set('level',1);
    if (this.registry.get('stage')===undefined) this.registry.set('stage',1);
    if (this.registry.get('zone')===undefined) this.registry.set('zone',1);

    // Track damage for perfect level detection
    this.damageTaken = 0;
    this.startingHealth = this.registry.get('health');

    // Track points earned this level for bonus calculation
    this.levelPointsEarned = 0;

    // Track items used this level (max 3)
    this.itemsUsedThisLevel = this.registry.get('itemsUsedThisLevel') || 0;

    // Point multiplier (from point boost consumable)
    this.pointMultiplier = this.registry.get('pointMultiplier') || 1;

    this.consequences = [
      'A stray dog trips over the tracks',
      'A sudden rainstorm reduces visibility',
      'You find an abandoned suitcase',
      'A loose plank causes a bump',
      'You spot an unexpected shortcut',
      'An old signal malfunctions',
      'You see something strange in the distance',
      'The track vibrates oddly',
      'A bird flies across your path'
    ];
  }
  create() {
    // Hide all containers
    hideAllContainers();

    // Hide menu DOM elements
    const domBg = document.getElementById('menu-bg'); if (domBg) domBg.style.display = 'none';
    const domLogo = document.getElementById('menu-logo'); if (domLogo) domLogo.style.display = 'none';
    const leaderboardBgLV = document.getElementById('leaderboard-container'); if (leaderboardBgLV) leaderboardBgLV.style.display='none';
    const gameOverBgLV = document.getElementById('gameover-bg'); if (gameOverBgLV) gameOverBgLV.style.display='none';
    document.body.style.backgroundColor = '';
    const levelBgElHide = document.getElementById('level-bg'); if (levelBgElHide) levelBgElHide.style.display = 'block';
    const btnWorldMapHide = document.getElementById('btn-worldmap'); if (btnWorldMapHide) btnWorldMapHide.style.display = 'none';
    const btnShopHide = document.getElementById('btn-shop'); if (btnShopHide) btnShopHide.style.display = 'none';
    const btnProfileHide = document.getElementById('btn-profile'); if (btnProfileHide) btnProfileHide.style.display = 'none';
    const btnLogoutHide = document.getElementById('btn-logout'); if (btnLogoutHide) btnLogoutHide.style.display = 'none';
    const btnLeaderboard = document.getElementById('btn-leaderboard'); if (btnLeaderboard) btnLeaderboard.style.display = 'none';
    const btnContinue = document.getElementById('btn-continue'); if (btnContinue) { btnContinue.style.display = 'none';
        btnContinue.onclick = null;
        const consBgHide = document.getElementById('consequence-container'); if (consBgHide) consBgHide.style.display='none';
        const consBg2 = document.getElementById('consequence-container'); if (consBg2) consBg2.style.display='none'; }
    const btnQuitReset = document.getElementById('btn-quit'); if (btnQuitReset) { btnQuitReset.style.display='none'; btnQuitReset.onclick=null; }
    const btnNextReset = document.getElementById('btn-next'); if (btnNextReset) { btnNextReset.style.display='none'; btnNextReset.onclick=null; }
    const domMenuBtn = document.getElementById('btn-menu'); if (domMenuBtn) { domMenuBtn.style.display='none'; domMenuBtn.onclick=null; }

    const btnQuitLBHide = document.getElementById('btn-quit'); if (btnQuitLBHide) { btnQuitLBHide.style.display='none'; btnQuitLBHide.onclick=null; }
    const btnSubmitImg2 = document.getElementById('btn-submit'); if (btnSubmitImg2) { btnSubmitImg2.style.display='none'; btnSubmitImg2.onclick=null; }
    const btnTryImg2 = document.getElementById('btn-try'); if (btnTryImg2) { btnTryImg2.style.display='none'; btnTryImg2.onclick=null; }
    const btnWorldMapGoLV = document.getElementById('btn-worldmap-go'); if (btnWorldMapGoLV) { btnWorldMapGoLV.style.display='none'; btnWorldMapGoLV.onclick=null; }
    const consBgReset = document.getElementById('consequence-container'); if (consBgReset) { consBgReset.style.display='none'; }

    const goTitleHideLV = document.getElementById('go-title'); if (goTitleHideLV) goTitleHideLV.style.display='none';

    // Get zone configuration
    const zoneId = this.registry.get('zone') || 1;
    const zoneConfig = ZoneConfig.find(z => z.id === zoneId) || ZoneConfig[0];

    // Background via DOM image - use zone-specific background
    const levelBgEl = document.getElementById('level-bg');
    if (levelBgEl) {
      // Set the appropriate background for this zone
      const bgMap = {
        1: 'assets/backgrounds/level_01_background.png',
        2: 'assets/backgrounds/level_02_background.png',
        3: 'assets/backgrounds/level_03_background.png',
        4: 'assets/backgrounds/level_04_background.png'
      };
      levelBgEl.src = bgMap[zoneId] || bgMap[1];
      levelBgEl.style.display = 'block';
    }

    // Show and update DOM-based HUD
    const gameHud = document.getElementById('game-hud');
    const isPortrait = window.innerHeight > window.innerWidth && window.innerWidth <= 1200;
    if (gameHud) gameHud.style.display = isPortrait ? 'flex' : 'block';

    // Style inventory button
    const earlyTestBtn = document.getElementById('hud-inventory-btn');
    if (earlyTestBtn) earlyTestBtn.style.background = 'rgba(0,0,0,0.6)';

    const hudHealth = document.getElementById('hud-health');
    const hudPoints = document.getElementById('hud-points');
    const hudLevel = document.getElementById('hud-level');
    const hudStage = document.getElementById('hud-stage');
    const hudZone = document.getElementById('hud-zone');

    if (hudHealth) hudHealth.textContent = 'Health: ' + this.registry.get('health');
    if (hudPoints) hudPoints.textContent = 'Points: ' + this.registry.get('points');
    if (hudLevel) hudLevel.textContent = 'Level: ' + this.registry.get('level');
    if (hudStage) hudStage.textContent = 'Stage: ' + this.registry.get('stage');
    if (hudZone) {
      hudZone.textContent = zoneConfig.name;
      hudZone.style.color = zoneConfig.color;
    }

    // Show point multiplier if active
    if (this.pointMultiplier > 1) {
      this.add.text(20, 80, '2x POINTS ACTIVE!', {font:'16px Arial', fill:'#FF9800'});
    }

    // Setup item bar and game inventory overlay
    this.setupItemBar();
    this.setupGameInventory();

    // Setup zone progress tracker
    const currentStage = this.registry.get('stage') || 1;
    if (currentStage === 1) {
      // Reset tracker at start of each level
      ZoneProgressTracker.reset(zoneConfig.choicesPerLevel);
      ZoneProgressTracker.updateTrolleySkin();
    }
    ZoneProgressTracker.show();

    // Moved down by 200px (from y=100 to y=300) and doubled font size (24px -> 48px)
    this.promptText = this.add.text(400,300, '', {font:'48px Arial', fill:'#fff', align:'center', wordWrap:{width:1400}}).setOrigin(0.5);

    // Menu button (DOM image) - position varies by orientation
    const domMenuBtn2 = document.getElementById('btn-menu');
    if (domMenuBtn2) {
      // Use setProperty with important to override portrait CSS that hides it
      domMenuBtn2.style.setProperty('display', 'block', 'important');
      domMenuBtn2.onclick = () => this.scene.start('MainMenuScene');

      // Portrait mode: top-left, smaller scale
      if (window.innerHeight > window.innerWidth && window.innerWidth <= 1200) {
        domMenuBtn2.style.setProperty('left', '8px', 'important');
        domMenuBtn2.style.setProperty('top', '8px', 'important');
        domMenuBtn2.style.setProperty('right', 'auto', 'important');
        domMenuBtn2.style.setProperty('bottom', 'auto', 'important');
        domMenuBtn2.style.setProperty('transform-origin', 'top left', 'important');
        domMenuBtn2.style.setProperty('transform', 'scale(0.3)', 'important');
      } else {
        // Landscape: bottom-right placement at 50% scale
        domMenuBtn2.style.right = '16px';
        domMenuBtn2.style.bottom = '16px';
        domMenuBtn2.style.left = '';
        domMenuBtn2.style.top = '';
        domMenuBtn2.style.transformOrigin = 'bottom right';
        domMenuBtn2.style.transform = 'scale(0.5)';
      }
    }

    // Position inventory button based on orientation (independent of menu button)
    const isPortraitMode = window.innerHeight > window.innerWidth && window.innerWidth <= 1200;
    const inventoryBtnMain = document.getElementById('hud-inventory-btn');

    // Set consistent inventory button style
    if (inventoryBtnMain) {
      inventoryBtnMain.style.setProperty('background', 'rgba(0,0,0,0.6)', 'important');
    }

    if (isPortraitMode && inventoryBtnMain) {
      // Must move to body because game-hud has transform which breaks position:fixed
      if (inventoryBtnMain.parentElement !== document.body) {
        document.body.appendChild(inventoryBtnMain);
      }
      inventoryBtnMain.style.setProperty('position', 'fixed', 'important');
      inventoryBtnMain.style.setProperty('left', '8px', 'important');
      inventoryBtnMain.style.setProperty('top', '45px', 'important');
      inventoryBtnMain.style.setProperty('right', 'auto', 'important');
      inventoryBtnMain.style.setProperty('bottom', 'auto', 'important');
      inventoryBtnMain.style.setProperty('width', '28px', 'important');
      inventoryBtnMain.style.setProperty('height', '28px', 'important');
      inventoryBtnMain.style.setProperty('z-index', '9999', 'important');
      inventoryBtnMain.style.setProperty('display', 'flex', 'important');
      inventoryBtnMain.style.setProperty('background', 'rgba(0,0,0,0.6)', 'important');
      inventoryBtnMain.style.setProperty('border', '2px solid #FFD700', 'important');
    } else if (inventoryBtnMain) {
      // Landscape: move inventory button back to game-hud if needed
      const gameHud = document.getElementById('game-hud');
      if (gameHud && inventoryBtnMain.parentElement === document.body) {
        gameHud.appendChild(inventoryBtnMain);
        inventoryBtnMain.style.cssText = 'position:absolute;right:20px;top:90px;width:40px;height:40px;background:rgba(0,0,0,0.6);border:2px solid #FFD700;border-radius:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;';
      }
    }

    // Hide quit button in game view
    const btnQuitLV = document.getElementById('btn-quit');
    if (btnQuitLV) {
      btnQuitLV.style.display = 'none';
    }

    // Set up DOM-based choice frames
    this.setupChoiceFrames();

    // Setup orientation change handler
    this._orientationHandler = () => this._handleOrientationChange();
    window.addEventListener('resize', this._orientationHandler);
    window.addEventListener('orientationchange', this._orientationHandler);
    this._lastOrientation = SwipeCardManager.shouldUseSwipeMode() ? 'portrait' : 'landscape';

    // Next level uses DOM image button (btn-next). It will be shown on level completion.

    // Start
    this.generateJunctions();
    this.junctionIndex = 0;
    this.showJunction();
  }

  // Handle orientation changes during gameplay
  _handleOrientationChange() {
    const isPortrait = SwipeCardManager.shouldUseSwipeMode();
    const newOrientation = isPortrait ? 'portrait' : 'landscape';

    // Only react if orientation actually changed
    if (newOrientation === this._lastOrientation) return;
    this._lastOrientation = newOrientation;

    // If we're in the middle of showing a junction (not showing consequence)
    const consContainer = document.getElementById('consequence-container');
    const isShowingConsequence = consContainer && consContainer.style.display === 'block';

    if (!isShowingConsequence && this.junctionIndex < this.junctions.length) {
      const j = this.junctions[this.junctionIndex];
      const choicesContainer = document.getElementById('choices-container');

      if (isPortrait) {
        // Switched to portrait: hide traditional choices, show swipe card
        if (choicesContainer) choicesContainer.style.display = 'none';
        SwipeCardManager.show(j.opts[0], j.opts[1], (idx) => this.handleChoice(idx));
      } else {
        // Switched to landscape: hide swipe card, show traditional choices
        SwipeCardManager.hide();
        if (choicesContainer) choicesContainer.style.display = '';

        // Re-populate and show choice frames
        j.opts.forEach((opt, i) => {
          const pts = (opt.pts >= 0 ? '+' : '') + opt.pts + ' pts';
          const hp = (opt.hp >= 0 ? '+' : '') + opt.hp + ' HP';
          const choiceText = document.getElementById(i === 0 ? 'choice-a-text' : 'choice-b-text');
          if (choiceText) {
            choiceText.innerHTML = `${opt.text}<br><span style="font-size:14px;color:#FFD700;">(${pts}, ${hp})</span>`;
          }
        });
        this.enableChoiceFrames(true);
      }
    }
  }

  setupItemBar() {
    const user = getUser();
    if (!user) return;

    const itemBar = document.getElementById('item-bar');
    if (!itemBar) return;

    const userConsumables = user.inventory.consumables;
    let hasAnyItems = false;

    // Data-driven item bar setup using ShopItems.consumables config
    ShopItems.consumables.forEach(itemConfig => {
      const btn = document.getElementById(itemConfig.buttonId);
      if (!btn) return;

      const owned = userConsumables[itemConfig.id] || 0;

      // Check if item should be shown
      // - Must own at least one
      // - If onePerLevel, check that multiplier isn't already active
      const canUse = owned > 0 && (!itemConfig.onePerLevel || this.pointMultiplier === 1);

      if (canUse) {
        btn.style.display = 'block';
        btn.style.width = '100%';
        btn.style.minHeight = '32px'; // Minimum touch target
        btn.textContent = `${itemConfig.buttonLabel} (${owned})`;
        btn.style.background = itemConfig.buttonColor;
        btn.onclick = () => this.useConsumable(itemConfig.id, itemConfig.value);
        hasAnyItems = true;
      } else {
        btn.style.display = 'none';
      }
    });

    // Items used counter
    const itemsUsedEl = document.getElementById('items-used');
    if (itemsUsedEl) {
      itemsUsedEl.textContent = `(${this.itemsUsedThisLevel}/${GAME_CONSTANTS.MAX_ITEMS_PER_LEVEL} used)`;
    }

    // Show or hide item bar (use flex for vertical layout)
    itemBar.style.display = hasAnyItems ? 'flex' : 'none';
  }

  setupGameInventory() {
    const inventoryBtn = document.getElementById('hud-inventory-btn');
    const overlay = document.getElementById('game-inventory-overlay');
    const closeBtn = document.getElementById('game-inventory-close');

    if (inventoryBtn && overlay) {
      inventoryBtn.onclick = () => {
        this.renderGameInventory();
        overlay.style.display = 'flex';
      };
    }

    if (closeBtn && overlay) {
      closeBtn.onclick = () => {
        overlay.style.display = 'none';
      };
    }

    // Close overlay when clicking outside panel
    if (overlay) {
      overlay.onclick = (e) => {
        if (e.target === overlay) {
          overlay.style.display = 'none';
        }
      };
    }
  }

  renderGameInventory() {
    const user = getUser();
    const itemsContainer = document.getElementById('game-inventory-items');
    const limitEl = document.getElementById('game-inventory-limit');

    if (!user || !itemsContainer) return;

    // Update limit text
    if (limitEl) {
      limitEl.textContent = `(${this.itemsUsedThisLevel}/${GAME_CONSTANTS.MAX_ITEMS_PER_LEVEL} items used this level)`;
    }

    const userConsumables = user.inventory.consumables || {};
    const hasAnyItems = Object.values(userConsumables).some(count => count > 0);

    if (!hasAnyItems) {
      itemsContainer.innerHTML = '<div style="color:#888;font-family:Arial;text-align:center;padding:20px;">No consumables owned.<br>Visit the Shop to buy items!</div>';
      return;
    }

    let html = '';
    const canUseMore = this.itemsUsedThisLevel < GAME_CONSTANTS.MAX_ITEMS_PER_LEVEL;

    ShopItems.consumables.forEach(itemConfig => {
      const count = userConsumables[itemConfig.id] || 0;
      if (count > 0) {
        // Check if this specific item can be used
        const canUseThis = canUseMore && (!itemConfig.onePerLevel || this.pointMultiplier === 1);
        const btnDisabled = !canUseThis;
        const btnStyle = canUseThis
          ? `background:${itemConfig.buttonColor};color:#fff;cursor:pointer;`
          : 'background:#666;color:#aaa;cursor:not-allowed;';

        html += `
          <div style="display:flex;align-items:center;gap:12px;padding:10px;background:rgba(255,255,255,0.1);border-radius:8px;">
            <div style="font-size:28px;width:40px;text-align:center;">${itemConfig.icon || ''}</div>
            <div style="flex:1;">
              <div style="color:#F5DEB3;font-family:Arial;font-size:14px;">${itemConfig.name}</div>
              <div style="color:#4CAF50;font-family:Arial;font-size:12px;">${itemConfig.effect}</div>
              <div style="color:#888;font-family:Arial;font-size:11px;">Owned: ${count}</div>
            </div>
            <button class="game-inv-use-btn" data-item-id="${itemConfig.id}" data-item-value="${itemConfig.value}" ${btnDisabled ? 'disabled' : ''}
              style="padding:8px 16px;border:none;border-radius:5px;font-family:Arial;font-size:12px;${btnStyle}">
              Use
            </button>
          </div>
        `;
      }
    });

    if (!canUseMore) {
      html += '<div style="color:#FF9800;font-family:Arial;font-size:12px;text-align:center;padding:10px;">Maximum items used this level!</div>';
    }

    itemsContainer.innerHTML = html;

    // Add click handlers to use buttons
    itemsContainer.querySelectorAll('.game-inv-use-btn').forEach(btn => {
      if (!btn.disabled) {
        btn.onclick = () => {
          const itemId = btn.getAttribute('data-item-id');
          const itemValue = parseInt(btn.getAttribute('data-item-value'), 10);
          this.useConsumable(itemId, itemValue);
          this.renderGameInventory(); // Refresh the overlay
        };
      }
    });
  }

  useConsumable(itemId, value) {
    if (this.itemsUsedThisLevel >= GAME_CONSTANTS.MAX_ITEMS_PER_LEVEL) {
      return; // Max items per level reached
    }

    const user = getUser();
    if (!user || user.inventory.consumables[itemId] <= 0) return;

    const healthBefore = this.registry.values.health;

    // Deduct item
    user.inventory.consumables[itemId]--;
    saveUser(user);

    // Apply effect
    if (itemId === 'hp_small' || itemId === 'hp_large') {
      this.registry.values.health += value;
      this.updateUI();
    } else if (itemId === 'point_boost') {
      this.pointMultiplier = value;
      this.registry.set('pointMultiplier', value);
      // Show indicator
      this.add.text(20, 80, '2x POINTS ACTIVE!', {font:'16px Arial', fill:'#FF9800'});
    }

    this.itemsUsedThisLevel++;
    this.registry.set('itemsUsedThisLevel', this.itemsUsedThisLevel);

    // Track item usage for analytics
    Analytics.trackItemUse(itemId, value, {
      zone: this.registry.get('selectedZone'),
      level: this.registry.get('currentLevel'),
      healthBefore: healthBefore,
      healthAfter: this.registry.values.health
    });

    // Refresh item bar
    this.setupItemBar();
  }

  setupChoiceFrames() {
    // Initialize SwipeCardManager for portrait mode
    SwipeCardManager.init();

    // In portrait swipe mode, traditional choice frames are hidden via CSS
    // Still set up click handlers for landscape mode
    const choiceA = UIManager.get('choice-a-frame');
    const choiceB = UIManager.get('choice-b-frame');

    if (choiceA) {
      InputHandler.addInteraction(choiceA, () => this.handleChoice(0));
      InputHandler.addHoverEffect(choiceA,
        () => { choiceA.style.filter = 'brightness(1.2)'; },
        () => { choiceA.style.filter = 'none'; }
      );
    }
    if (choiceB) {
      InputHandler.addInteraction(choiceB, () => this.handleChoice(1));
      InputHandler.addHoverEffect(choiceB,
        () => { choiceB.style.filter = 'brightness(1.2)'; },
        () => { choiceB.style.filter = 'none'; }
      );
    }
  }

  showQuestionFrames(show) {
    UIManager.showQuestionFrames(show);
  }

  enableChoiceFrames(enabled) {
    UIManager.enableChoiceFrames(enabled);
  }

  generateJunctions() {
    const zoneId = this.registry.get('zone') || 1;
    const selectedDifficulty = this.registry.get('selectedDifficulty') || 1;
    const zoneConfig = ZoneConfig.find(z => z.id === zoneId) || ZoneConfig[0];
    const pool = ZonePrompts[zoneId] || ZonePrompts[1];

    // Calculate combined difficulty multiplier:
    // Base zone multiplier + (selectedDifficulty - 1) * DIFFICULTY_BASE_INCREMENT
    const combinedMultiplier = zoneConfig.difficultyMod + (selectedDifficulty - 1) * GAME_CONSTANTS.DIFFICULTY_BASE_INCREMENT;

    // Apply difficulty modifier to HP costs AND points
    const modifiedPool = pool.map(j => {
      const modified = JSON.parse(JSON.stringify(j)); // Deep clone
      modified.opts = modified.opts.map(opt => {
        // Scale HP loss by combined difficulty (don't scale gains)
        if (opt.hp < 0) {
          opt.hp = Math.floor(opt.hp * combinedMultiplier);
        }
        // Scale points by combined difficulty (more risk = more reward)
        opt.pts = Math.floor(opt.pts * combinedMultiplier);
        return opt;
      });
      return modified;
    });

    Phaser.Utils.Array.Shuffle(modifiedPool);
    // Number of choices based on zone
    this.junctions = modifiedPool.slice(0, zoneConfig.choicesPerLevel);
  }
  showJunction() {
    if (this.registry.get('health') <= 0) return this.scene.start('GameOverScene');
    if (this.junctionIndex >= this.junctions.length) return this.onLevelComplete();
    const j = this.junctions[this.junctionIndex];

    // Update DOM-based question frame
    const questionText = document.getElementById('question-text');
    if (questionText) questionText.textContent = j.prompt;

    // Check if we should use swipe mode (portrait orientation)
    if (SwipeCardManager.shouldUseSwipeMode()) {
      // Portrait mode: show swipe card instead of traditional choices
      this.showQuestionFrames(true);
      // Hide the choices container (CSS also hides it, but ensure it)
      const choicesContainer = document.getElementById('choices-container');
      if (choicesContainer) choicesContainer.style.display = 'none';

      // Show swipe card with callback to handleChoice
      SwipeCardManager.show(j.opts[0], j.opts[1], (idx) => this.handleChoice(idx));
    } else {
      // Landscape mode: traditional side-by-side choices
      // Update DOM-based choice frames
      j.opts.forEach((opt, i) => {
        const pts = (opt.pts >= 0 ? '+' : '') + opt.pts + ' pts';
        const hp = (opt.hp >= 0 ? '+' : '') + opt.hp + ' HP';
        const choiceText = document.getElementById(i === 0 ? 'choice-a-text' : 'choice-b-text');
        if (choiceText) {
          choiceText.innerHTML = `${opt.text}<br><span style="font-size:14px;color:#FFD700;">(${pts}, ${hp})</span>`;
        }
      });

      // Show the frames and enable interaction
      this.showQuestionFrames(true);
      this.enableChoiceFrames(true);
    }

    // Also keep Phaser text as fallback (hidden for now)
    this.promptText.setText(j.prompt).setVisible(false);
  }
  handleChoice(idx) {
    const j = this.junctions[this.junctionIndex], opt = j.opts[idx];

    // Record choice in progress tracker (A=0, B=1)
    ZoneProgressTracker.recordChoice(idx === 0 ? 'A' : 'B');

    // Apply point multiplier
    const pointsEarned = Math.floor(opt.pts * this.pointMultiplier);
    this.registry.values.points += pointsEarned;
    this.registry.values.health += opt.hp;

    // Track points earned this level for bonus calculation
    this.levelPointsEarned += pointsEarned;

    // Track damage for perfect level
    if (opt.hp < 0) {
      this.damageTaken += Math.abs(opt.hp);
    }

    // Update user stats and add points immediately to persistent balance
    const user = getUser();
    if (user) {
      user.stats.choicesMade++;
      user.inventory.currency += pointsEarned;
      // Ensure points never go below 0
      if (user.inventory.currency < 0) user.inventory.currency = 0;
      saveUser(user);
    }

    // Track choice for analytics
    Analytics.trackChoice({
      zone: this.registry.get('selectedZone'),
      level: this.registry.get('currentLevel'),
      stage: this.junctionIndex + 1,
      prompt: j.prompt,
      chosenOption: idx,
      chosenText: opt.text,
      pointsGained: pointsEarned,
      hpChange: opt.hp,
      healthAfter: this.registry.values.health
    });

    {
      const currentStage = this.registry.get('stage');
      const maxStages = this.junctions.length;
      const nextStage = Math.min(currentStage + 1, maxStages);
      this.registry.set('stage', nextStage);
    }
    this.updateUI();
    // disable choice frames
    this.enableChoiceFrames(false);
    // risk-based consequence
    const risk=opt.pts;
    const randH=Phaser.Math.Between(-risk,Math.floor(risk*0.5));
    const randP=Phaser.Math.Between(-Math.ceil(risk*0.5),Math.ceil(risk*0.5));
    const desc=Phaser.Utils.Array.GetRandom(this.consequences);
    this.showConsequencePopup(desc,randH,randP);
  }
  showConsequencePopup(desc, randH, randP) {
    // Hide question and choice frames while popup is active
    this.showQuestionFrames(false);
    this.promptText.setVisible(false);
    this.promptText.setAlpha(0);
    const btnNextHide = document.getElementById('btn-next');
    if (btnNextHide) { btnNextHide.style.display='none'; btnNextHide.onclick=null; }

    // Hide swipe card if in portrait mode
    SwipeCardManager.hide();

    // Show consequence frame
    const consContainer = document.getElementById('consequence-container');
    if (consContainer) consContainer.style.display = 'block';

    // Hide menu and inventory buttons while consequence is showing
    const btnMenu = document.getElementById('btn-menu');
    const btnInventory = document.getElementById('hud-inventory-btn');
    if (btnMenu) btnMenu.style.display = 'none';
    if (btnInventory) btnInventory.style.display = 'none';

    // Populate consequence text using DOM elements
    const consText = document.getElementById('consequence-text');
    const consStats = document.getElementById('consequence-stats');
    if (consText) consText.textContent = desc;
    if (consStats) consStats.textContent = `Health: ${randH>=0?'+':''}${randH}  Points: ${randP>=0?'+':''}${randP}`;

    // Move continue button into consequence frame
    const btnContainer = document.getElementById('consequence-btn-container');
    const btnContinue = document.getElementById('btn-continue');
    if (btnContinue && btnContainer) {
      btnContainer.appendChild(btnContinue);
      btnContinue.style.display = 'block';
      btnContinue.style.position = 'relative';
      btnContinue.style.left = '';
      btnContinue.style.top = '';
      btnContinue.style.transform = 'scale(0.8)';
      btnContinue.style.transformOrigin = 'center';
      btnContinue.onclick = () => {
        // Apply effects (with point multiplier)
        this.registry.values.points += Math.floor(randP * this.pointMultiplier);
        this.registry.values.health += randH;

        // Track consequence damage
        if (randH < 0) {
          this.damageTaken += Math.abs(randH);
        }

        this.updateUI();
        // Cleanup and proceed
        document.body.appendChild(btnContinue);
        btnContinue.style.position = 'fixed';
        btnContinue.style.display = 'none';
        btnContinue.onclick = null;
        if (consContainer) consContainer.style.display = 'none';
        // Restore menu and inventory buttons (use setProperty with important to override portrait CSS)
        if (btnMenu) btnMenu.style.setProperty('display', 'block', 'important');
        if (btnInventory) btnInventory.style.setProperty('display', 'flex', 'important');
        this.promptText.setAlpha(1);
        this.promptText.setVisible(true);
        this.junctionIndex++;
        this.showJunction();
      };
    }
  }
  updateUI() {
    UIManager.updateHUD({
      health: this.registry.get('health'),
      points: this.registry.get('points'),
      level: this.registry.get('level'),
      stage: this.registry.get('stage')
    });
  }
  onLevelComplete() {
    // Hide swipe card if in portrait mode
    SwipeCardManager.hide();

    const currentLevel = this.registry.get('level');
    const zoneId = this.registry.get('zone') || 1;
    const isPerfect = this.damageTaken === 0;
    const currentScore = this.registry.get('points');

    console.log('[DEBUG] onLevelComplete called - Zone:', zoneId, 'Level:', currentLevel);

    // Save user progress
    const user = getUser();
    if (user) {
      // Check if this level was already completed
      const levelKey = `${zoneId}-${currentLevel}`;
      const existingHigh = user.progress.highScores[levelKey] || 0;

      if (currentScore > existingHigh) {
        user.progress.highScores[levelKey] = currentScore;
      }

      // Record level completion if not already done
      const alreadyCompleted = user.progress.completedLevels.some(
        l => l.zone === zoneId && l.level === currentLevel
      );
      console.log('[DEBUG] Already completed?', alreadyCompleted, '- Current completedLevels:', JSON.stringify(user.progress.completedLevels));
      if (!alreadyCompleted) {
        user.progress.completedLevels.push({
          zone: zoneId,
          level: currentLevel,
          score: currentScore,
          perfect: isPerfect
        });
        console.log('[DEBUG] Added level', currentLevel, '- New completedLevels:', JSON.stringify(user.progress.completedLevels));
      }

      // Update stats
      if (isPerfect) {
        user.stats.perfectLevels++;
      }

      // Calculate bonus points (zone bonus and perfect bonus)
      // Base points were already added during gameplay in handleChoice
      const zone = ZoneConfig.find(z => z.id === zoneId) || ZoneConfig[0];
      let bonusPoints = 0;

      // Zone bonus: extra points based on zone currencyBonus
      if (zone.currencyBonus > 1.0) {
        bonusPoints += Math.floor(this.levelPointsEarned * (zone.currencyBonus - 1.0));
      }

      // Perfect bonus: extra if no damage taken
      if (isPerfect) {
        bonusPoints += Math.floor(this.levelPointsEarned * GAME_CONSTANTS.PERFECT_LEVEL_BONUS);
      }

      // Add bonus points
      if (bonusPoints > 0) {
        user.inventory.currency += bonusPoints;
      }

      // Track total points earned this level (base + bonus)
      const totalLevelPoints = this.levelPointsEarned + bonusPoints;

      // Check zone completion
      const zoneConfig = ZoneConfig.find(z => z.id === zoneId);
      const zoneLevelsCompleted = user.progress.completedLevels.filter(l => l.zone === zoneId).length;
      const selectedDifficulty = this.registry.get('selectedDifficulty') || 1;
      let isZoneComplete = false;

      // Zone is complete when player just finished the final level (level 5)
      // currentLevel is the level that was just completed
      if (currentLevel >= zoneConfig.levelsRequired) {
        isZoneComplete = true;

        // Initialize zoneCompletions if needed
        if (!user.progress.zoneCompletions) {
          user.progress.zoneCompletions = {};
        }

        // Update highest difficulty completed for this zone
        const currentHighest = user.progress.zoneCompletions[zoneId] || 0;
        if (selectedDifficulty > currentHighest) {
          user.progress.zoneCompletions[zoneId] = selectedDifficulty;
        }

        // Unlock next zone
        const nextZone = ZoneConfig.find(z => z.id === zoneId + 1);
        if (nextZone && user.progress.currentZone < nextZone.id) {
          user.progress.currentZone = nextZone.id;
          user.stats.zonesCompleted++;
        }
      }

      // Check and award achievements
      const newAchievements = checkAchievements(user);
      user.achievements = [...user.achievements, ...newAchievements];

      saveUser(user);

      // Track level completion for analytics
      Analytics.trackEvent('level_complete', {
        zone: zoneId,
        level: currentLevel,
        score: currentScore,
        isPerfect: isPerfect,
        bonusPoints: bonusPoints,
        totalPoints: totalLevelPoints,
        difficulty: selectedDifficulty,
        isZoneComplete: isZoneComplete,
        newAchievements: newAchievements.map(a => a.id)
      });

      // Show level complete with points earned (using DOM element for debug outline support)
      let completeMsg = `Level Complete!\n+${totalLevelPoints} Points`;
      if (bonusPoints > 0) {
        completeMsg += ` (${bonusPoints} bonus)`;
      }
      if (isPerfect) {
        completeMsg += '\nPERFECT!';
      }
      const levelCompleteEl = document.getElementById('level-complete-text');
      if (levelCompleteEl) {
        levelCompleteEl.textContent = completeMsg;
        levelCompleteEl.style.display = 'block';
      }
      this.promptText.setText(''); // Clear Phaser text

      // Store for use in showing popup
      this.isZoneComplete = isZoneComplete;
      this.zoneCompleteZoneId = zoneId;
    } else {
      const levelCompleteEl = document.getElementById('level-complete-text');
      if (levelCompleteEl) {
        levelCompleteEl.textContent = 'Level Complete!';
        levelCompleteEl.style.display = 'block';
      }
      this.promptText.setText(''); // Clear Phaser text
      this.isZoneComplete = false;
    }

    this.registry.values.level += 1;
    this.registry.values.stage = 1;

    // Reset level points tracking for next level
    this.levelPointsEarned = 0;

    // Reset item usage and point multiplier for next level
    this.registry.set('itemsUsedThisLevel', 0);
    this.registry.set('pointMultiplier', 1);

    this.showQuestionFrames(false);

    // Hide item bar on level complete
    const itemBar = document.getElementById('item-bar');
    if (itemBar) itemBar.style.display = 'none';

    // Check if zone is complete - show zone complete popup instead of next level button
    if (this.isZoneComplete) {
      this.showZoneCompletePopup(this.zoneCompleteZoneId);
    } else {
      const btnNextShow = document.getElementById('btn-next');
      if (btnNextShow) {
        btnNextShow.style.display = 'block';
        btnNextShow.style.left = '50%';
        btnNextShow.style.top = '500px';
        btnNextShow.style.transform = 'translateX(-50%)';
        btnNextShow.onclick = () => this.startNextLevel();
      }
    }
    this.updateUI();
  }
  startNextLevel() {
    const btnNextHide2 = document.getElementById('btn-next');
    if (btnNextHide2) { btnNextHide2.style.display='none'; btnNextHide2.onclick=null; }

    // Hide level complete text
    const levelCompleteEl = document.getElementById('level-complete-text');
    if (levelCompleteEl) levelCompleteEl.style.display = 'none';

    // Reset tracking for new level
    this.damageTaken = 0;
    this.startingHealth = this.registry.get('health');
    this.itemsUsedThisLevel = 0;
    this.pointMultiplier = this.registry.get('pointMultiplier') || 1;

    // Re-setup item bar for the new level
    this.setupItemBar();

    // Reset zone progress tracker for the new level
    const zoneId = this.registry.get('zone') || 1;
    const zoneConfig = ZoneConfig.find(z => z.id === zoneId) || ZoneConfig[0];
    ZoneProgressTracker.reset(zoneConfig.choicesPerLevel);

    this.generateJunctions();
    this.junctionIndex=0;
    this.showJunction();
  }

  showZoneCompletePopup(zoneId) {
    // Hide level complete text when showing zone complete popup
    const levelCompleteEl = document.getElementById('level-complete-text');
    if (levelCompleteEl) levelCompleteEl.style.display = 'none';

    // Hide progress tracker for zone complete
    ZoneProgressTracker.hide();

    const container = document.getElementById('zone-complete-container');
    const frame = document.getElementById('zone-complete-frame');
    const subtitle = document.getElementById('zone-complete-subtitle');
    const btnContainer = document.getElementById('zone-complete-btn-container');

    if (!container || !frame) return;

    // Hide menu and inventory buttons while zone complete is showing
    const btnMenu = document.getElementById('btn-menu');
    const btnInventory = document.getElementById('hud-inventory-btn');
    if (btnMenu) btnMenu.style.display = 'none';
    if (btnInventory) btnInventory.style.display = 'none';

    // Determine next zone name or if all zones complete
    const nextZone = ZoneConfig.find(z => z.id === zoneId + 1);
    const isAllComplete = !nextZone;

    if (isAllComplete) {
      subtitle.textContent = ' All Zones Complete! ';
    } else {
      subtitle.textContent = `${nextZone.name} Unlocked!`;
    }

    // Create continue button
    btnContainer.innerHTML = '';
    const continueBtn = document.createElement('img');
    continueBtn.src = 'assets/buttons/button_continue.png';
    continueBtn.alt = 'Continue';
    continueBtn.style.cssText = 'width:180px;height:auto;cursor:pointer;';
    continueBtn.onclick = () => {
      // Hide popup
      container.style.display = 'none';
      frame.classList.remove('zone-complete-animate');

      // Restore menu and inventory buttons
      if (btnMenu) btnMenu.style.setProperty('display', 'block', 'important');
      if (btnInventory) btnInventory.style.setProperty('display', 'flex', 'important');

      if (isAllComplete) {
        // Return to main menu
        this.scene.start('MainMenuScene');
      } else {
        // Start next zone
        this.startNextZone(nextZone.id);
      }
    };
    btnContainer.appendChild(continueBtn);

    // Show container and animate frame
    container.style.display = 'block';
    frame.classList.add('zone-complete-animate');
  }

  startNextZone(nextZoneId) {
    // Hide zone complete popup if visible
    const zoneCompleteContainer = document.getElementById('zone-complete-container');
    if (zoneCompleteContainer) zoneCompleteContainer.style.display = 'none';

    // Set up for new zone (points persist, don't reset)
    this.registry.set('zone', nextZoneId);
    this.registry.set('level', 1);
    this.registry.set('stage', 1);
    this.registry.set('health', 10);
    // Points are persistent - don't reset
    this.registry.set('selectedDifficulty', 1); // Reset to difficulty 1 for new zone
    this.registry.set('pointMultiplier', 1);
    this.registry.set('itemsUsedThisLevel', 0);

    // Restart the LevelScene with new zone
    this.scene.restart();
  }

  // Cleanup event listeners when scene shuts down
  shutdown() {
    // Clean up orientation change handlers
    if (this._orientationHandler) {
      window.removeEventListener('resize', this._orientationHandler);
      window.removeEventListener('orientationchange', this._orientationHandler);
      this._orientationHandler = null;
    }

    // Hide swipe card
    SwipeCardManager.hide();

    // Clear choice frame handlers
    const choiceA = UIManager.get('choice-a-frame');
    const choiceB = UIManager.get('choice-b-frame');
    if (choiceA) {
      choiceA.onclick = null;
      choiceA.onmouseover = null;
      choiceA.onmouseout = null;
    }
    if (choiceB) {
      choiceB.onclick = null;
      choiceB.onmouseover = null;
      choiceB.onmouseout = null;
    }

    // Clear button handlers
    EventTracker.clearClickHandlers(['btn-menu', 'btn-quit', 'btn-next', 'btn-continue']);

    // Clear item bar button handlers
    ShopItems.consumables.forEach(item => {
      const btn = document.getElementById(item.buttonId);
      if (btn) btn.onclick = null;
    });

    // Move inventory button back to game-hud if it was moved to body for portrait mode
    const inventoryBtn = document.getElementById('hud-inventory-btn');
    const gameHud = document.getElementById('game-hud');
    if (inventoryBtn && gameHud && inventoryBtn.parentElement === document.body) {
      gameHud.appendChild(inventoryBtn);
      inventoryBtn.style.cssText = 'position:absolute;right:20px;top:90px;width:40px;height:40px;background:rgba(0,0,0,0.6);border:2px solid #FFD700;border-radius:8px;cursor:pointer;display:flex;align-items:center;justify-content:center;';
    }
  }
}

class GameOverScene extends Phaser.Scene {
  constructor(){ super('GameOverScene'); }
  init(){
    const score = this.registry.get('points');
    const high = this.registry.get('highScore') || 0;
    if (score > high) this.registry.set('highScore', score);

    // Update user stats
    const user = getUser();
    if (user) {
      user.stats.totalGames++;
      user.stats.totalDeaths++;
      user.stats.totalPoints += score;

      // Points were already added during gameplay in handleChoice
      // Just show current total points on game over screen
      this.totalPoints = user.inventory.currency;

      // Check survivor achievement
      if (this.registry.get('health') === 1 && !user.achievements.includes('survivor')) {
        user.achievements.push('survivor');
      }

      // Check and award other achievements
      const newAchievements = checkAchievements(user);
      user.achievements = [...new Set([...user.achievements, ...newAchievements])];

      saveUser(user);

      // Track game over for analytics
      Analytics.trackEvent('game_over', {
        zone: this.registry.get('zone') || 1,
        level: this.registry.get('level'),
        finalScore: score,
        totalPoints: user.inventory.currency,
        healthAtDeath: this.registry.get('health'),
        totalGames: user.stats.totalGames,
        difficulty: this.registry.get('selectedDifficulty') || 1
      });
    }

    // Reset point multiplier and item tracking
    this.registry.set('pointMultiplier', 1);
    this.registry.set('itemsUsedThisLevel', 0);
  }
  create(){
    // Hide all containers
    hideAllContainers();

    // Hide zone progress tracker
    ZoneProgressTracker.hide();

    // Hide menu DOM elements that don't belong on this screen
    const domBg = document.getElementById('menu-bg'); if (domBg) domBg.style.display='none';
    const domLogo = document.getElementById('menu-logo'); if (domLogo) domLogo.style.display='none';
    const levelBgHide = document.getElementById('level-bg'); if (levelBgHide) levelBgHide.style.display='none';
    const leaderboardBgHideGO = document.getElementById('leaderboard-container'); if (leaderboardBgHideGO) leaderboardBgHideGO.style.display='none';
    document.body.style.backgroundColor = '';
    const gameOverBgShowGO = document.getElementById('gameover-bg'); if (gameOverBgShowGO) gameOverBgShowGO.style.display='block';
    const btnStart = document.getElementById('btn-start'); if (btnStart) btnStart.style.display='none';
    const btnLeaderboard = document.getElementById('btn-leaderboard'); if (btnLeaderboard) btnLeaderboard.style.display='none';
    const btnContinue = document.getElementById('btn-continue'); if (btnContinue) { btnContinue.style.display='none'; btnContinue.onclick=null; }
    const domMenuBtnX = document.getElementById('btn-menu'); if (domMenuBtnX) { domMenuBtnX.style.display='none'; domMenuBtnX.onclick=null; }
    const btnQuitGOHide = document.getElementById('btn-quit'); if (btnQuitGOHide) { btnQuitGOHide.style.display='none'; btnQuitGOHide.onclick=null; }
    const consBgHideFinal = document.getElementById('consequence-container'); if (consBgHideFinal) consBgHideFinal.style.display='none';

    // Game Over title image (DOM)
    const goTitle = document.getElementById('go-title');
    if (goTitle) {
      goTitle.style.display = 'block';
      goTitle.style.width = 'auto';
      goTitle.style.left = '50%';
      goTitle.style.transform = 'translateX(-50%)';
      goTitle.style.zIndex = '9';
    }

    // Show total points (DOM element for debug outline support)
    const goTotalPoints = document.getElementById('go-total-points');
    if (goTotalPoints && this.totalPoints !== undefined) {
      goTotalPoints.textContent = `Total Points: ${this.totalPoints}`;
      goTotalPoints.style.display = 'block';
      goTotalPoints.style.top = '200px';
    }

    // Get button container and buttons
    const btnContainer = document.getElementById('go-btn-container');
    const btnWorldMapGo = document.getElementById('btn-worldmap-go');
    const btnTry = document.getElementById('btn-try');
    const btnSubmit = document.getElementById('btn-submit');
    const btnMenu = document.getElementById('btn-menu');
    const CONTAINER_WIDTH = 180;

    // Helper to hide all game over buttons and container
    const hideAllGOButtons = () => {
      // Move buttons back to body to preserve them for next game over
      [btnWorldMapGo, btnTry, btnSubmit, btnMenu].forEach(btn => {
        if (btn && btn.parentElement === btnContainer) {
          btn.style.display = 'none';
          btn.style.position = 'fixed';
          btn.onclick = null;
          document.body.appendChild(btn);
        }
      });
      if (btnContainer) btnContainer.style.display = 'none';
      if (goTotalPoints) goTotalPoints.style.display = 'none';
    };

    if (btnContainer) {
      // Clear container and set up
      btnContainer.innerHTML = '';
      btnContainer.style.display = 'flex';
      btnContainer.style.top = '240px';

      // Button order: World Map, Try Again, Submit Score, Menu
      const buttons = [
        { el: btnWorldMapGo, action: () => { hideAllGOButtons(); this.scene.start('WorldMapScene'); } },
        { el: btnTry, action: () => {
          this.registry.set('health', 10);
          this.registry.set('level', 1);
          this.registry.set('stage', 1);
          this.registry.set('pointMultiplier', 1);
          this.registry.set('itemsUsedThisLevel', 0);
          // Reset progress tracker to clear any lingering state
          const zoneId = this.registry.get('zone') || 1;
          const zoneConfig = ZoneConfig.find(z => z.id === zoneId) || ZoneConfig[0];
          ZoneProgressTracker.reset(zoneConfig.choicesPerLevel);
          hideAllGOButtons();
          this.scene.start('LevelScene');
        }},
        { el: btnSubmit, action: () => {
          const initials = prompt('Enter initials', 'AAA') || '---';
          const board = getLeaderboard();
          const user = getUser();
          const totalPoints = user ? user.inventory.currency : this.registry.get('points');
          board.push({ initials: initials.slice(0, 3).toUpperCase(), score: totalPoints });
          board.sort((a, b) => b.score - a.score);
          saveLeaderboard(board.slice(0, 10));
          const goBg = document.getElementById('gameover-bg'); if (goBg) goBg.style.display = 'none';
          hideAllGOButtons();
          this.scene.start('LeaderboardScene');
        }},
        { el: btnMenu, action: () => { hideAllGOButtons(); this.scene.start('MainMenuScene'); } }
      ];

      // Add each button to container with uniform width
      buttons.forEach(({ el, action }) => {
        if (el) {
          el.style.position = 'relative';
          el.style.left = '';
          el.style.top = '';
          el.style.right = '';
          el.style.bottom = '';
          el.style.transform = '';
          el.style.width = CONTAINER_WIDTH + 'px';
          el.style.height = 'auto';
          el.style.display = 'block';
          el.style.cursor = 'pointer';
          el.onclick = action;
          btnContainer.appendChild(el);
        }
      });
    }

    // Layout the game over screen elements
    // ========== ADJUST THIS VALUE TO CHANGE TITLE SIZE ==========
    const DESIRED_TITLE_HEIGHT = 200; // Target height for game over title (will scale down if needed)
    // ============================================================

    const layoutGameOver = () => {
      const vh = window.innerHeight;
      const titleEl = document.getElementById('go-title');
      const pointsEl = document.getElementById('go-total-points');
      const containerEl = document.getElementById('go-btn-container');
      if (!titleEl || !pointsEl || !containerEl) return;

      const containerRect = containerEl.getBoundingClientRect();
      if (containerRect.height === 0) {
        setTimeout(layoutGameOver, 50);
        return;
      }

      // Fixed spacing values
      const titleTop = 30;
      const gapAfterTitle = 10;
      const gapAfterPoints = 20;
      const pointsHeight = 30;
      const bottomMargin = 20;

      // Calculate how much space we need for everything except title
      const fixedSpace = titleTop + gapAfterTitle + pointsHeight + gapAfterPoints + containerRect.height + bottomMargin;

      // Calculate max title height that still fits everything on screen
      const maxTitleHeight = vh - fixedSpace;

      // Use desired height or scale down to fit
      const titleHeight = Math.min(DESIRED_TITLE_HEIGHT, Math.max(60, maxTitleHeight));

      // Position all elements
      titleEl.style.top = titleTop + 'px';
      titleEl.style.height = titleHeight + 'px';

      const pointsTop = titleTop + titleHeight + gapAfterTitle;
      pointsEl.style.top = pointsTop + 'px';

      const containerTop = pointsTop + pointsHeight + gapAfterPoints;
      containerEl.style.top = containerTop + 'px';
    };

    setTimeout(layoutGameOver, 0);
    setTimeout(layoutGameOver, 150);
  }
}

class LeaderboardScene extends Phaser.Scene {
  constructor(){ super('LeaderboardScene'); }
  create(){
    // Hide all containers
    hideAllContainers();

    // Hide menu DOM/logo/buttons and any popup DOM controls
    const domBg = document.getElementById('menu-bg'); if (domBg) domBg.style.display='none';
    const domLogo = document.getElementById('menu-logo'); if (domLogo) domLogo.style.display='none';
    const levelBgHide = document.getElementById('level-bg'); if (levelBgHide) levelBgHide.style.display='none';
    const gameOverBgHideLB = document.getElementById('gameover-bg'); if (gameOverBgHideLB) gameOverBgHideLB.style.display='none';
    const btnStart = document.getElementById('btn-start'); if (btnStart) btnStart.style.display='none';
    const btnLeaderboard = document.getElementById('btn-leaderboard'); if (btnLeaderboard) btnLeaderboard.style.display='none';
    const btnContinue = document.getElementById('btn-continue'); if (btnContinue) { btnContinue.style.display='none'; btnContinue.onclick=null; }
    const domMenuBtn = document.getElementById('btn-menu'); if (domMenuBtn) { domMenuBtn.style.display='none'; domMenuBtn.onclick=null; }
    const btnSubmitImgLB = document.getElementById('btn-submit'); if (btnSubmitImgLB) { btnSubmitImgLB.style.display='none'; btnSubmitImgLB.onclick=null; }
    const btnTryImgLB = document.getElementById('btn-try'); if (btnTryImgLB) { btnTryImgLB.style.display='none'; btnTryImgLB.onclick=null; }
    const btnWorldMapGoLB = document.getElementById('btn-worldmap-go'); if (btnWorldMapGoLB) { btnWorldMapGoLB.style.display='none'; btnWorldMapGoLB.onclick=null; }
    const consBgHideLB = document.getElementById('consequence-container'); if (consBgHideLB) consBgHideLB.style.display='none';
    const goTitleHideLB2 = document.getElementById('go-title'); if (goTitleHideLB2) goTitleHideLB2.style.display='none';
    // Hide game over container (buttons are handled by hideAllContainers)
    const goBtnContainerLB = document.getElementById('go-btn-container'); if (goBtnContainerLB) goBtnContainerLB.style.display='none';
    const goTotalPointsLB = document.getElementById('go-total-points'); if (goTotalPointsLB) goTotalPointsLB.style.display='none';

    // Hide all main menu buttons
    const btnWorldMap = document.getElementById('btn-worldmap'); if (btnWorldMap) btnWorldMap.style.display='none';
    const btnShop = document.getElementById('btn-shop'); if (btnShop) btnShop.style.display='none';
    const btnProfile = document.getElementById('btn-profile'); if (btnProfile) btnProfile.style.display='none';
    const btnLogout = document.getElementById('btn-logout'); if (btnLogout) btnLogout.style.display='none';
    const btnQuitHide = document.getElementById('btn-quit'); if (btnQuitHide) btnQuitHide.style.display='none';

    // Hide welcome and points displays
    const welcomeDisplay = document.getElementById('menu-welcome-display'); if (welcomeDisplay) welcomeDisplay.style.display='none';
    const pointsDisplay = document.getElementById('menu-points-display'); if (pointsDisplay) pointsDisplay.style.display='none';

    // Set dark background and show leaderboard container
    document.body.style.backgroundColor = '#222';

    // Show leaderboard container (frame is inside)
    const leaderboardContainer = document.getElementById('leaderboard-container');
    if (leaderboardContainer) leaderboardContainer.style.display = 'block';

    // Populate entries using DOM elements (max 10 entries to fit in frame)
    const entriesContainer = document.getElementById('leaderboard-entries');
    if (entriesContainer) {
      entriesContainer.innerHTML = ''; // Clear previous entries
      const board = getLeaderboard().slice(0, 10); // Limit to top 10
      board.forEach((e, i) => {
        const entry = document.createElement('div');
        entry.id = `leaderboard-entry-${i}`;
        entry.style.cssText = 'display:flex;justify-content:space-between;font-family:Arial,sans-serif;font-size:clamp(14px, 2.5vh, 24px);color:#fff;flex-shrink:0;';
        entry.innerHTML = `<span id="leaderboard-entry-${i}-name">${i+1}. ${e.initials}</span><span id="leaderboard-entry-${i}-score">${e.score}</span>`;
        entriesContainer.appendChild(entry);
      });
    }

    // Back button (Menu button) - inside the frame's safe area
    const btnContainer = document.getElementById('leaderboard-btn-container');
    const domMenuBtnLB = document.getElementById('btn-menu');
    if (domMenuBtnLB && btnContainer) {
      // Move button into the leaderboard frame
      btnContainer.appendChild(domMenuBtnLB);
      domMenuBtnLB.style.display = 'block';
      domMenuBtnLB.style.position = 'relative';
      domMenuBtnLB.style.left = '';
      domMenuBtnLB.style.top = '';
      domMenuBtnLB.style.right = '';
      domMenuBtnLB.style.bottom = '';
      domMenuBtnLB.style.transform = 'scale(0.5)';
      domMenuBtnLB.style.transformOrigin = 'center';
      domMenuBtnLB.onclick = () => {
        // Move button back to body before hiding
        document.body.appendChild(domMenuBtnLB);
        domMenuBtnLB.style.display = 'none';
        domMenuBtnLB.style.position = 'fixed';
        domMenuBtnLB.onclick = null;
        const lbContainer = document.getElementById('leaderboard-container');
        if (lbContainer) lbContainer.style.display = 'none';
        this.scene.start('MainMenuScene');
      };
    }
  }
}

// =====================================================
// WORLD MAP SCENE
// =====================================================
class WorldMapScene extends Phaser.Scene {
  constructor() { super('WorldMapScene'); }

  create() {
    // Hide all DOM elements
    hideAllContainers();
    const domBg = document.getElementById('menu-bg'); if (domBg) domBg.style.display = 'none';
    const domLogo = document.getElementById('menu-logo'); if (domLogo) domLogo.style.display = 'none';
    const levelBg = document.getElementById('level-bg'); if (levelBg) levelBg.style.display = 'none';
    const leaderboardBg = document.getElementById('leaderboard-container'); if (leaderboardBg) leaderboardBg.style.display = 'none';
    const gameOverBg = document.getElementById('gameover-bg'); if (gameOverBg) gameOverBg.style.display = 'none';
    const consBg = document.getElementById('consequence-container'); if (consBg) consBg.style.display = 'none';
    const goTitle = document.getElementById('go-title'); if (goTitle) goTitle.style.display = 'none';

    // Hide all buttons
    const buttons = ['btn-worldmap', 'btn-leaderboard', 'btn-shop', 'btn-profile', 'btn-logout', 'btn-continue', 'btn-next', 'btn-menu', 'btn-submit', 'btn-try', 'btn-worldmap-go', 'btn-quit'];
    buttons.forEach(id => {
      const btn = document.getElementById(id);
      if (btn) { btn.style.display = 'none'; btn.onclick = null; }
    });

    // Show world map background and container
    const worldmapBg = document.getElementById('worldmap-bg');
    if (worldmapBg) worldmapBg.style.display = 'block';
    const worldmapContainer = document.getElementById('worldmap-container');
    if (worldmapContainer) worldmapContainer.style.display = 'block';

    // Hide menu button on world map (removing it for now per user request)
    const menuBtnEarly = document.getElementById('btn-menu');
    if (menuBtnEarly) {
      menuBtnEarly.style.display = 'none';
    }

    // Show debug unlock button on world map
    const debugUnlockBtn = document.getElementById('debug-unlock-btn');
    if (debugUnlockBtn) debugUnlockBtn.style.display = 'flex';

    // Get user data
    const user = getUser();
    const unlockedZone = user ? user.progress.currentZone : 1;

    // Store selected zone for start button
    this.selectedZone = null;

    // Setup zone markers with click handlers
    const zoneMarkers = document.querySelectorAll('.zone-marker');
    zoneMarkers.forEach(marker => {
      const zoneId = parseInt(marker.getAttribute('data-zone'));
      const zone = ZoneConfig.find(z => z.id === zoneId);
      if (!zone) return;

      // Check zone unlock status
      const prevZone = ZoneConfig.find(z => z.id === zone.id - 1);
      let isUnlocked = zone.id === 1;
      if (prevZone && user) {
        const prevZoneCompleted = user.progress.completedLevels.filter(l => l.zone === prevZone.id).length;
        isUnlocked = prevZoneCompleted >= zone.unlockRequirement || zone.id <= unlockedZone;
      }

      // Reset classes and apply lock status
      marker.classList.remove('selected', 'locked');
      const lockOverlay = marker.querySelector('.zone-lock-overlay');
      if (!isUnlocked) {
        marker.classList.add('locked');
        if (lockOverlay) lockOverlay.style.display = 'flex';
      } else {
        if (lockOverlay) lockOverlay.style.display = 'none';
      }

      // Click to show zone details (CSS handles hover via :hover pseudo-class)
      marker.onclick = () => {
        if (!isUnlocked) return; // Ignore clicks on locked zones
        this.showZoneDetails(zone, user, isUnlocked);
        // Update selected state via CSS class
        zoneMarkers.forEach(m => m.classList.remove('selected'));
        marker.classList.add('selected');
        this.selectedZone = zoneId;
      };
    });

    // Setup start button in detail panel
    const startBtn = document.getElementById('btn-zone-start');
    if (startBtn) {
      startBtn.onclick = () => {
        if (this.selectedZone) {
          worldmapContainer.style.display = 'none';
          this.registry.set('zone', this.selectedZone);
          this.registry.set('health', 10);
          // Points are persistent - load from user's balance in LevelScene init
          this.registry.set('level', 1);
          this.registry.set('stage', 1);
          this.registry.set('pointMultiplier', 1);
          this.registry.set('itemsUsedThisLevel', 0);
          this.registry.set('selectedDifficulty', this.selectedDifficulty || 1);
          // Clear registry points so it gets reloaded from user in LevelScene
          this.registry.set('points', undefined);
          this.scene.start('LevelScene');
        }
      };
    }

    // Setup back button
    const backBtn = document.getElementById('btn-worldmap-back');
    if (backBtn) {
      backBtn.onclick = () => {
        worldmapContainer.style.display = 'none';
        const detailPanel = document.getElementById('zone-detail-frame');
        if (detailPanel) detailPanel.style.display = 'none';
        this.scene.start('MainMenuScene');
      };
    }

    // Menu button removed from world map for now

    // Auto-select first unlocked zone
    const firstMarker = document.querySelector('.zone-marker[data-zone="1"]');
    if (firstMarker) firstMarker.click();
  }

  showZoneDetails(zone, user, isUnlocked) {
    const panel = document.getElementById('zone-detail-frame');
    if (!panel) return;

    // Get completion stats
    let levelsCompleted = 0;
    let zoneCompletions = 0; // Highest difficulty completed
    if (user) {
      levelsCompleted = user.progress.completedLevels.filter(l => l.zone === zone.id).length;
      // Initialize zoneCompletions if needed
      if (!user.progress.zoneCompletions) {
        user.progress.zoneCompletions = {};
      }
      zoneCompletions = user.progress.zoneCompletions[zone.id] || 0;
      console.log('[DEBUG] showZoneDetails - Zone:', zone.id, 'completedLevels:', JSON.stringify(user.progress.completedLevels), 'Count for this zone:', levelsCompleted, 'Zone completions:', zoneCompletions);
    }

    // Update panel content
    document.getElementById('zone-detail-name').textContent = zone.name;
    document.getElementById('zone-detail-desc').textContent = zone.description;

    // Difficulty stars (base zone difficulty)
    const diffStars = ''.repeat(Math.ceil(zone.difficultyMod));
    document.getElementById('zone-detail-difficulty').textContent = diffStars + ` (${zone.difficultyMod}x base)`;

    document.getElementById('zone-detail-choices').textContent = `${zone.choicesPerLevel} choices per level`;

    // Progress bar
    const progressPercent = (levelsCompleted / zone.levelsRequired) * 100;
    document.getElementById('zone-detail-progress-bar').style.width = `${Math.min(progressPercent, 100)}%`;
    document.getElementById('zone-detail-progress-text').textContent = `${levelsCompleted}/${zone.levelsRequired} Levels Completed`;

    // Setup difficulty selector
    const difficultySelector = document.getElementById('zone-difficulty-selector');
    const difficultyMultiplierText = document.getElementById('zone-difficulty-multiplier');
    const difficultyBtns = document.querySelectorAll('.difficulty-btn');

    if (isUnlocked && difficultySelector) {
      difficultySelector.style.display = 'block';

      // Default selected difficulty to 1
      this.selectedDifficulty = 1;

      // Update difficulty buttons
      difficultyBtns.forEach(btn => {
        const diff = parseInt(btn.getAttribute('data-difficulty'));

        // Difficulty unlock logic:
        // Diff 1: Always available once zone unlocked
        // Diff 2: Unlocked after completing zone once (zoneCompletions >= 1)
        // Diff 3: Unlocked after completing zone at Diff 2 (zoneCompletions >= 2)
        const isUnlockedDiff = diff <= zoneCompletions + 1;

        // Reset classes
        btn.classList.remove('selected', 'locked');

        if (!isUnlockedDiff) {
          btn.classList.add('locked');
          btn.innerHTML = '';
        } else {
          btn.textContent = diff;
          if (diff === 1) {
            btn.classList.add('selected');
          }
        }

        btn.onclick = () => {
          if (!isUnlockedDiff) return;

          // Update selection
          difficultyBtns.forEach(b => b.classList.remove('selected'));
          btn.classList.add('selected');
          this.selectedDifficulty = diff;

          // Update multiplier display
          const multiplier = zone.difficultyMod + (diff - 1) * GAME_CONSTANTS.DIFFICULTY_BASE_INCREMENT;
          difficultyMultiplierText.textContent = `${multiplier.toFixed(1)}x Multiplier`;
        };
      });

      // Set initial multiplier display
      const initialMultiplier = zone.difficultyMod + (this.selectedDifficulty - 1) * GAME_CONSTANTS.DIFFICULTY_BASE_INCREMENT;
      difficultyMultiplierText.textContent = `${initialMultiplier.toFixed(1)}x Multiplier`;
    } else if (difficultySelector) {
      difficultySelector.style.display = 'none';
    }

    // Lock status
    const lockedDiv = document.getElementById('zone-detail-locked');
    const startBtn = document.getElementById('btn-zone-start');
    if (isUnlocked) {
      lockedDiv.style.display = 'none';
      startBtn.style.display = 'block';
      startBtn.style.opacity = '1';
      startBtn.style.cursor = 'pointer';
    } else {
      lockedDiv.style.display = 'block';
      startBtn.style.display = 'block';
      startBtn.style.opacity = '0.4';
      startBtn.style.cursor = 'not-allowed';
    }

    // Show panel
    panel.style.display = 'block';
  }
}

// =====================================================
// SHOP SCENE
// =====================================================
class ShopScene extends Phaser.Scene {
  constructor() { super('ShopScene'); }

  create() {
    // Hide all DOM elements
    hideAllContainers();
    const domBg = document.getElementById('menu-bg'); if (domBg) domBg.style.display = 'none';
    const domLogo = document.getElementById('menu-logo'); if (domLogo) domLogo.style.display = 'none';
    const levelBg = document.getElementById('level-bg'); if (levelBg) levelBg.style.display = 'none';
    const leaderboardBg = document.getElementById('leaderboard-container'); if (leaderboardBg) leaderboardBg.style.display = 'none';
    const gameOverBg = document.getElementById('gameover-bg'); if (gameOverBg) gameOverBg.style.display = 'none';

    // Hide all buttons
    const buttons = ['btn-worldmap', 'btn-leaderboard', 'btn-shop', 'btn-profile', 'btn-logout', 'btn-continue', 'btn-next', 'btn-menu', 'btn-submit', 'btn-try', 'btn-worldmap-go', 'btn-quit'];
    buttons.forEach(id => {
      const btn = document.getElementById(id);
      if (btn) { btn.style.display = 'none'; btn.onclick = null; }
    });

    // Show shop background and container
    const shopBg = document.getElementById('shop-bg');
    if (shopBg) shopBg.style.display = 'block';
    const shopContainer = document.getElementById('shop-container');
    if (shopContainer) shopContainer.style.display = 'block';

    this.currentTab = 'cosmetics';
    this.currentPage = 0;
    // Use 4 items per page in portrait mode (2x2), 6 in landscape
    this.itemsPerPage = this._isPortraitMode() ? 4 : 6;
    this.renderShop();

    // Update items per page on orientation change
    this._orientationHandler = () => {
      const newItemsPerPage = this._isPortraitMode() ? 4 : 6;
      if (newItemsPerPage !== this.itemsPerPage) {
        this.itemsPerPage = newItemsPerPage;
        this.currentPage = 0;
        this.renderShop();
      }
    };
    window.addEventListener('resize', this._orientationHandler);
    window.addEventListener('orientationchange', this._orientationHandler);

    // Setup tabs
    const tabCosmetics = document.getElementById('tab-cosmetics');
    const tabConsumables = document.getElementById('tab-consumables');

    if (tabCosmetics) {
      tabCosmetics.onclick = () => {
        this.currentTab = 'cosmetics';
        this.currentPage = 0; // Reset to first page when switching tabs
        tabCosmetics.style.background = '#FFD700';
        tabCosmetics.style.color = '#000';
        tabConsumables.style.background = '#555';
        tabConsumables.style.color = '#fff';
        this.renderShop();
      };
    }

    if (tabConsumables) {
      tabConsumables.onclick = () => {
        this.currentTab = 'consumables';
        this.currentPage = 0; // Reset to first page when switching tabs
        tabConsumables.style.background = '#FFD700';
        tabConsumables.style.color = '#000';
        tabCosmetics.style.background = '#555';
        tabCosmetics.style.color = '#fff';
        this.renderShop();
      };
    }

    // Setup pagination buttons
    const prevBtn = document.getElementById('shop-prev');
    const nextBtn = document.getElementById('shop-next');

    if (prevBtn) {
      prevBtn.onclick = () => {
        if (this.currentPage > 0) {
          this.currentPage--;
          this.renderShop();
        }
      };
    }

    if (nextBtn) {
      nextBtn.onclick = () => {
        const items = this.currentTab === 'cosmetics' ? ShopItems.cosmetics : ShopItems.consumables;
        const totalPages = Math.ceil(items.length / this.itemsPerPage);
        if (this.currentPage < totalPages - 1) {
          this.currentPage++;
          this.renderShop();
        }
      };
    }

    // Create back button in container
    const btnContainer = document.getElementById('shop-btn-container');
    if (btnContainer) {
      btnContainer.innerHTML = '';
      const backBtn = document.createElement('img');
      backBtn.src = 'assets/buttons/button_menu.png';
      backBtn.alt = 'Menu';
      backBtn.style.cssText = 'width:auto;height:clamp(40px, 8vh, 60px);cursor:pointer;transition:transform 0.1s;';
      backBtn.onmouseover = () => backBtn.style.transform = 'scale(1.05)';
      backBtn.onmouseout = () => backBtn.style.transform = 'scale(1)';
      backBtn.onclick = () => {
        shopContainer.style.display = 'none';
        this.scene.start('MainMenuScene');
      };
      btnContainer.appendChild(backBtn);
    }
  }

  renderShop() {
    const user = getUser();
    if (!user) return;

    // Update points display with icon (using cached element)
    const pointsEl = UIManager.get('shop-points');
    if (pointsEl) {
      pointsEl.innerHTML = `<img src="assets/icons/icon_currency.png" alt="Points" title="Points" style="width:28px;height:28px;vertical-align:middle;margin-right:8px;"/>${user.inventory.currency} Points`;
    }

    // Get items grid container (using cached element)
    const itemsGrid = UIManager.get('shop-items-grid');
    if (!itemsGrid) return;

    // Get the items for current tab
    const allItems = this.currentTab === 'cosmetics' ? ShopItems.cosmetics : ShopItems.consumables;
    const totalPages = Math.ceil(allItems.length / this.itemsPerPage);

    // Ensure current page is valid
    if (this.currentPage >= totalPages) this.currentPage = Math.max(0, totalPages - 1);

    // Get items for current page
    const startIndex = this.currentPage * this.itemsPerPage;
    const pageItems = allItems.slice(startIndex, startIndex + this.itemsPerPage);

    // Update pagination display (using cached elements)
    const pageInfo = UIManager.get('shop-page-info');
    const prevBtn = UIManager.get('shop-prev');
    const nextBtn = UIManager.get('shop-next');

    if (pageInfo) {
      pageInfo.textContent = `Page ${this.currentPage + 1} / ${Math.max(1, totalPages)}`;
    }
    if (prevBtn) {
      prevBtn.style.opacity = this.currentPage > 0 ? '1' : '0.4';
      prevBtn.style.cursor = this.currentPage > 0 ? 'pointer' : 'not-allowed';
    }
    if (nextBtn) {
      nextBtn.style.opacity = this.currentPage < totalPages - 1 ? '1' : '0.4';
      nextBtn.style.cursor = this.currentPage < totalPages - 1 ? 'pointer' : 'not-allowed';
    }

    // Use DocumentFragment for batch DOM updates (performance optimization)
    const fragment = document.createDocumentFragment();

    if (this.currentTab === 'cosmetics') {
      pageItems.forEach(item => {
        const isOwned = user.inventory.cosmetics.includes(item.id);
        const isEquipped = user.equipped.trolleyAppearance === item.id;
        const canAfford = user.inventory.currency >= item.price;

        const itemCard = document.createElement('div');
        itemCard.style.cssText = `
          display: inline-block;
          width: clamp(80px, 18vw, 110px);
          margin: 3px;
          padding: 6px;
          background: rgba(255,255,255,0.1);
          border-radius: 6px;
          text-align: center;
          vertical-align: top;
        `;

        // Image preview (with fallback to color)
        const preview = document.createElement('div');
        preview.style.cssText = `
          width: 90%;
          height: clamp(35px, 6vh, 50px);
          margin: 0 auto 4px;
          background: ${item.preview ? `url('${item.preview}') center/contain no-repeat` : item.color};
          border-radius: 4px;
          border: 2px solid ${isEquipped ? '#FFD700' : 'transparent'};
        `;

        // Name
        const name = document.createElement('div');
        name.style.cssText = 'color: #F5DEB3; font-family: Arial; font-size: clamp(9px, 1.3vh, 12px); margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
        name.textContent = item.name;

        // Price/Status
        const status = document.createElement('div');
        status.style.cssText = 'color: #FFD700; font-family: Arial; font-size: clamp(8px, 1.2vh, 10px); margin-bottom: 4px;';
        if (isOwned) {
          status.textContent = isEquipped ? 'EQUIPPED' : 'OWNED';
          status.style.color = isEquipped ? '#4CAF50' : '#888';
        } else {
          status.textContent = ` ${item.price}`;
        }

        // Button
        const btn = document.createElement('button');
        btn.style.cssText = `
          padding: 4px 10px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-family: Arial;
          font-size: clamp(9px, 1.3vh, 11px);
        `;

        if (isOwned) {
          if (isEquipped) {
            btn.textContent = 'Equipped';
            btn.style.background = '#666';
            btn.style.color = '#aaa';
            btn.style.cursor = 'default';
          } else {
            btn.textContent = 'Equip';
            btn.style.background = '#4CAF50';
            btn.style.color = '#fff';
            btn.onclick = () => {
              user.equipped.trolleyAppearance = item.id;
              saveUser(user);
              this.renderShop();
            };
          }
        } else {
          btn.textContent = 'Buy';
          btn.style.background = canAfford ? '#FFD700' : '#666';
          btn.style.color = canAfford ? '#000' : '#aaa';
          btn.style.cursor = canAfford ? 'pointer' : 'not-allowed';
          if (canAfford) {
            btn.onclick = () => {
              // Re-check user can still afford (in case of race conditions)
              const currentUser = getUser();
              if (!currentUser || currentUser.inventory.currency < item.price) {
                this.renderShop();
                return;
              }
              currentUser.inventory.currency -= item.price;
              // Ensure points never go below 0
              if (currentUser.inventory.currency < 0) currentUser.inventory.currency = 0;
              currentUser.inventory.cosmetics.push(item.id);
              // Check collector achievement
              const newAchievements = checkAchievements(currentUser);
              currentUser.achievements = [...new Set([...currentUser.achievements, ...newAchievements])];
              saveUser(currentUser);
              this.renderShop();
            };
          }
        }

        itemCard.appendChild(preview);
        itemCard.appendChild(name);
        itemCard.appendChild(status);
        itemCard.appendChild(btn);

        fragment.appendChild(itemCard);
      });
    } else {
      // Consumables tab
      pageItems.forEach(item => {
        const owned = user.inventory.consumables[item.id] || 0;
        const canAfford = user.inventory.currency >= item.price;

        const itemCard = document.createElement('div');
        itemCard.style.cssText = `
          display: inline-block;
          width: clamp(80px, 18vw, 110px);
          margin: 3px;
          padding: 6px;
          background: rgba(255,255,255,0.1);
          border-radius: 6px;
          text-align: center;
          vertical-align: top;
        `;

        // Icon (from item config)
        const icon = document.createElement('div');
        icon.style.cssText = 'font-size: clamp(18px, 3.5vh, 24px); margin-bottom: 2px;';
        icon.textContent = item.icon || '';

        // Name
        const name = document.createElement('div');
        name.style.cssText = 'color: #F5DEB3; font-family: Arial; font-size: clamp(9px, 1.3vh, 12px); margin-bottom: 2px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;';
        name.textContent = item.name;

        // Effect
        const effect = document.createElement('div');
        effect.style.cssText = 'color: #4CAF50; font-family: Arial; font-size: clamp(8px, 1.1vh, 10px); margin-bottom: 2px;';
        effect.textContent = item.effect;

        // Owned count
        const ownedText = document.createElement('div');
        ownedText.style.cssText = 'color: #888; font-family: Arial; font-size: clamp(7px, 1vh, 9px); margin-bottom: 2px;';
        ownedText.textContent = `Owned: ${owned}`;

        // Price
        const price = document.createElement('div');
        price.style.cssText = 'color: #FFD700; font-family: Arial; font-size: clamp(8px, 1.2vh, 10px); margin-bottom: 4px;';
        price.textContent = ` ${item.price}`;

        // Buy button
        const btn = document.createElement('button');
        btn.style.cssText = `
          padding: 4px 10px;
          border: none;
          border-radius: 4px;
          cursor: ${canAfford ? 'pointer' : 'not-allowed'};
          font-family: Arial;
          font-size: clamp(9px, 1.3vh, 11px);
          background: ${canAfford ? '#FFD700' : '#666'};
          color: ${canAfford ? '#000' : '#aaa'};
        `;
        btn.textContent = 'Buy';
        if (canAfford) {
          btn.onclick = () => {
            // Re-check user can still afford (in case of race conditions)
            const currentUser = getUser();
            if (!currentUser || currentUser.inventory.currency < item.price) {
              this.renderShop();
              return;
            }
            currentUser.inventory.currency -= item.price;
            // Ensure points never go below 0
            if (currentUser.inventory.currency < 0) currentUser.inventory.currency = 0;
            currentUser.inventory.consumables[item.id] = (currentUser.inventory.consumables[item.id] || 0) + 1;
            saveUser(currentUser);
            this.renderShop();
          };
        }

        itemCard.appendChild(icon);
        itemCard.appendChild(name);
        itemCard.appendChild(effect);
        itemCard.appendChild(ownedText);
        itemCard.appendChild(price);
        itemCard.appendChild(btn);

        fragment.appendChild(itemCard);
      });
    }

    // Clear and append fragment in single DOM operation (performance optimization)
    itemsGrid.innerHTML = '';
    itemsGrid.appendChild(fragment);
  }

  // Check if in portrait mode
  _isPortraitMode() {
    return window.innerHeight > window.innerWidth && window.innerWidth <= 1200;
  }

  // Cleanup on scene shutdown
  shutdown() {
    if (this._orientationHandler) {
      window.removeEventListener('resize', this._orientationHandler);
      window.removeEventListener('orientationchange', this._orientationHandler);
      this._orientationHandler = null;
    }
  }
}

// =====================================================
// PROFILE SCENE
// =====================================================
class ProfileScene extends Phaser.Scene {
  constructor() { super('ProfileScene'); }

  init(data) {
    // Accept optional tab parameter (e.g., { tab: 'inventory' })
    this.initialTab = data && data.tab ? data.tab : 'stats';
  }

  create() {
    // Hide all DOM elements
    hideAllContainers();
    const domBg = document.getElementById('menu-bg'); if (domBg) domBg.style.display = 'none';
    const domLogo = document.getElementById('menu-logo'); if (domLogo) domLogo.style.display = 'none';
    const levelBg = document.getElementById('level-bg'); if (levelBg) levelBg.style.display = 'none';
    const leaderboardBg = document.getElementById('leaderboard-container'); if (leaderboardBg) leaderboardBg.style.display = 'none';
    const gameOverBg = document.getElementById('gameover-bg'); if (gameOverBg) gameOverBg.style.display = 'none';

    // Hide all buttons
    const buttons = ['btn-worldmap', 'btn-leaderboard', 'btn-shop', 'btn-profile', 'btn-logout', 'btn-continue', 'btn-next', 'btn-menu', 'btn-submit', 'btn-try', 'btn-worldmap-go', 'btn-quit'];
    buttons.forEach(id => {
      const btn = document.getElementById(id);
      if (btn) { btn.style.display = 'none'; btn.onclick = null; }
    });

    // Show profile background and container
    const profileBg = document.getElementById('profile-bg');
    if (profileBg) profileBg.style.display = 'block';
    const profileContainer = document.getElementById('profile-container');
    if (profileContainer) profileContainer.style.display = 'block';

    const user = getUser();
    if (!user) {
      this.scene.start('LoginScene');
      return;
    }

    this.currentTab = this.initialTab;

    // Setup tab buttons
    const tabStats = document.getElementById('tab-stats');
    const tabInventory = document.getElementById('tab-inventory');
    const tabAchievements = document.getElementById('tab-achievements');

    const setActiveTab = (tabName) => {
      this.currentTab = tabName;
      // Update tab button styles
      [tabStats, tabInventory, tabAchievements].forEach(tab => {
        if (tab) {
          tab.style.background = '#555';
          tab.style.color = '#fff';
        }
      });
      const activeTabEl = tabName === 'stats' ? tabStats : (tabName === 'inventory' ? tabInventory : tabAchievements);
      if (activeTabEl) {
        activeTabEl.style.background = '#FFD700';
        activeTabEl.style.color = '#000';
      }
      // Render content
      if (tabName === 'stats') this.renderStats();
      else if (tabName === 'inventory') this.renderInventory();
      else if (tabName === 'achievements') this.renderAchievements();
    };

    if (tabStats) tabStats.onclick = () => setActiveTab('stats');
    if (tabInventory) tabInventory.onclick = () => setActiveTab('inventory');
    if (tabAchievements) tabAchievements.onclick = () => setActiveTab('achievements');

    // Create back button in container
    const btnContainer = document.getElementById('profile-btn-container');
    if (btnContainer) {
      btnContainer.innerHTML = '';
      const backBtn = document.createElement('img');
      backBtn.src = 'assets/buttons/button_menu.png';
      backBtn.alt = 'Menu';
      backBtn.style.cssText = 'width:auto;height:clamp(40px, 8vh, 60px);cursor:pointer;transition:transform 0.1s;';
      backBtn.onmouseover = () => backBtn.style.transform = 'scale(1.05)';
      backBtn.onmouseout = () => backBtn.style.transform = 'scale(1)';
      backBtn.onclick = () => {
        profileContainer.style.display = 'none';
        this.scene.start('MainMenuScene');
      };
      btnContainer.appendChild(backBtn);
    }

    // Set initial tab
    setActiveTab(this.currentTab);
  }

  renderStats() {
    const user = getUser();
    if (!user) return;

    const contentArea = document.getElementById('profile-tab-content');
    if (!contentArea) return;

    contentArea.innerHTML = `
      <div style="text-align:center;margin-bottom:15px;">
        <div style="font-size:clamp(36px, 6vh, 64px);">${user.isGuest ? '' : ''}</div>
        <h2 style="color:#FFD700;font-family:Georgia,serif;margin:8px 0;font-size:clamp(18px, 3vh, 28px);text-shadow:1px 1px 2px #000;">${user.username}</h2>
        <p style="color:#F5DEB3;font-family:Arial;font-size:clamp(10px, 1.5vh, 14px);text-shadow:1px 1px 2px #000;">
          ${user.isGuest ? 'Guest Account' : 'Registered Player'} |
          Joined: ${new Date(user.createdAt).toLocaleDateString()}
        </p>
      </div>
      <div style="display:grid;grid-template-columns:repeat(3, 1fr);gap:8px;text-align:center;">
        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;">
          <div style="color:#FFD700;font-size:clamp(16px, 3vh, 24px);font-family:Arial;text-shadow:1px 1px 2px #000;">${user.inventory.currency}</div>
          <div style="color:#F5DEB3;font-size:clamp(9px, 1.3vh, 12px);font-family:Arial;">Points</div>
        </div>
        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;">
          <div style="color:#4CAF50;font-size:clamp(16px, 3vh, 24px);font-family:Arial;text-shadow:1px 1px 2px #000;">${user.stats.totalGames}</div>
          <div style="color:#F5DEB3;font-size:clamp(9px, 1.3vh, 12px);font-family:Arial;">Games Played</div>
        </div>
        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;">
          <div style="color:#2196F3;font-size:clamp(16px, 3vh, 24px);font-family:Arial;text-shadow:1px 1px 2px #000;">${user.stats.totalPoints}</div>
          <div style="color:#F5DEB3;font-size:clamp(9px, 1.3vh, 12px);font-family:Arial;">Total Points</div>
        </div>
        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;">
          <div style="color:#FF9800;font-size:clamp(16px, 3vh, 24px);font-family:Arial;text-shadow:1px 1px 2px #000;">${user.stats.choicesMade}</div>
          <div style="color:#F5DEB3;font-size:clamp(9px, 1.3vh, 12px);font-family:Arial;">Choices Made</div>
        </div>
        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;">
          <div style="color:#E91E63;font-size:clamp(16px, 3vh, 24px);font-family:Arial;text-shadow:1px 1px 2px #000;">${user.stats.perfectLevels}</div>
          <div style="color:#F5DEB3;font-size:clamp(9px, 1.3vh, 12px);font-family:Arial;">Perfect Levels</div>
        </div>
        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:8px;">
          <div style="color:#9C27B0;font-size:clamp(16px, 3vh, 24px);font-family:Arial;text-shadow:1px 1px 2px #000;">${user.progress.completedLevels.length}</div>
          <div style="color:#F5DEB3;font-size:clamp(9px, 1.3vh, 12px);font-family:Arial;">Levels Done</div>
        </div>
      </div>
    `;
  }

  renderInventory() {
    const user = getUser();
    if (!user) return;

    const contentArea = document.getElementById('profile-tab-content');
    if (!contentArea) return;

    let html = '';

    // Trolley Skins Section
    html += `<div style="margin-bottom:15px;">
      <h3 style="color:#FFD700;font-family:Georgia,serif;font-size:clamp(14px, 2.5vh, 20px);margin:0 0 10px 0;text-shadow:1px 1px 2px #000;">Trolley Skins</h3>
      <div style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;">`;

    // Get owned cosmetics
    const ownedCosmetics = user.inventory.cosmetics || [];
    const equippedSkin = user.equipped ? user.equipped.trolleyAppearance : 'trolley_default';

    if (ownedCosmetics.length === 0) {
      html += `<div style="color:#888;font-family:Arial;font-size:clamp(11px, 1.8vh, 14px);padding:20px;">No skins owned yet. Visit the Shop!</div>`;
    } else {
      ShopItems.cosmetics.filter(item => ownedCosmetics.includes(item.id)).forEach(item => {
        const isEquipped = equippedSkin === item.id;
        html += `
          <div style="width:80px;padding:8px;background:rgba(0,0,0,0.3);border-radius:8px;text-align:center;border:2px solid ${isEquipped ? '#FFD700' : 'transparent'};">
            <div style="width:60px;height:35px;margin:0 auto 5px;background:${item.preview ? `url('${item.preview}') center/contain no-repeat` : item.color};border-radius:4px;"></div>
            <div style="color:#F5DEB3;font-family:Arial;font-size:clamp(8px, 1.2vh, 11px);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${item.name}</div>
            ${isEquipped ? '<div style="color:#4CAF50;font-size:clamp(7px, 1vh, 10px);font-family:Arial;">EQUIPPED</div>' : ''}
          </div>
        `;
      });
    }

    html += `</div></div>`;

    // Consumables Section
    html += `<div>
      <h3 style="color:#FFD700;font-family:Georgia,serif;font-size:clamp(14px, 2.5vh, 20px);margin:0 0 10px 0;text-shadow:1px 1px 2px #000;">Consumables</h3>
      <div style="display:flex;flex-wrap:wrap;gap:8px;justify-content:center;">`;

    // Get owned consumables
    const ownedConsumables = user.inventory.consumables || {};
    const hasConsumables = Object.values(ownedConsumables).some(count => count > 0);

    if (!hasConsumables) {
      html += `<div style="color:#888;font-family:Arial;font-size:clamp(11px, 1.8vh, 14px);padding:20px;">No consumables owned. Visit the Shop!</div>`;
    } else {
      ShopItems.consumables.forEach(item => {
        const count = ownedConsumables[item.id] || 0;
        if (count > 0) {
          html += `
            <div style="width:70px;padding:8px;background:rgba(0,0,0,0.3);border-radius:8px;text-align:center;position:relative;">
              <div style="font-size:clamp(20px, 4vh, 32px);margin-bottom:3px;">${item.icon || ''}</div>
              <div style="color:#F5DEB3;font-family:Arial;font-size:clamp(8px, 1.2vh, 11px);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${item.name}</div>
              <div style="position:absolute;top:3px;right:3px;background:#FFD700;color:#000;font-size:clamp(9px, 1.3vh, 12px);font-family:Arial;font-weight:bold;padding:2px 5px;border-radius:10px;">x${count}</div>
            </div>
          `;
        }
      });
    }

    html += `</div></div>`;

    contentArea.innerHTML = html;
  }

  renderAchievements() {
    const user = getUser();
    if (!user) return;

    const contentArea = document.getElementById('profile-tab-content');
    if (!contentArea) return;

    let html = '<div style="display:flex;flex-wrap:wrap;justify-content:center;gap:8px;">';

    AchievementDefs.forEach(achievement => {
      const earned = user.achievements.includes(achievement.id);
      html += `
        <div style="
          width:70px;
          padding:8px;
          background:${earned ? 'rgba(76, 175, 80, 0.3)' : 'rgba(0,0,0,0.3)'};
          border-radius:8px;
          text-align:center;
          opacity:${earned ? '1' : '0.5'};
        ">
          <div style="font-size:clamp(18px, 3vh, 28px);">${earned ? achievement.icon : ''}</div>
          <div style="color:#F5DEB3;font-size:clamp(8px, 1.2vh, 11px);font-family:Arial;margin-top:4px;">${achievement.name}</div>
        </div>
      `;
    });

    html += '</div>';
    contentArea.innerHTML = html;
  }
}

// =====================================================
// GAME INITIALIZATION
// =====================================================
// Initialize UIManager
UIManager.init();

// Initialize ZoneProgressTracker
ZoneProgressTracker.init();

// Check if user exists to determine starting scene
const existingUser = getUser();

// Build scene array with correct starting scene first
const allScenes = [LoginScene, MainMenuScene, LevelScene, GameOverScene, LeaderboardScene, WorldMapScene, ShopScene, ProfileScene];

// If user exists, start with MainMenuScene; otherwise start with LoginScene
const orderedScenes = existingUser
  ? [MainMenuScene, LoginScene, LevelScene, GameOverScene, LeaderboardScene, WorldMapScene, ShopScene, ProfileScene]
  : allScenes;

const config = {
  type: Phaser.AUTO,
  width: 800,
  height: 600,
  transparent: true,
  scene: orderedScenes,
  // Phase 3: Responsive scaling
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH,
    width: 800,
    height: 600
  },
  // Phase 3: Touch support
  input: {
    touch: true,
    activePointers: 3
  }
};

const game = new Phaser.Game(config);
</script>
</body>
</html>
